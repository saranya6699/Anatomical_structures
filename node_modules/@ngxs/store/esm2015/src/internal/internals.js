/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { META_KEY, META_OPTIONS_KEY, SELECTOR_META_KEY } from '../symbols';
/**
 * @record
 * @template T, U
 */
export function StateClassInternal() { }
if (false) {
    /* Skipping unnamed member:
    [META_KEY]?: MetaDataModel;*/
    /* Skipping unnamed member:
    [META_OPTIONS_KEY]?: StoreOptions<U>;*/
}
/**
 * @record
 * @template T
 */
export function StateOperations() { }
if (false) {
    /**
     * @return {?}
     */
    StateOperations.prototype.getState = function () { };
    /**
     * @param {?} val
     * @return {?}
     */
    StateOperations.prototype.setState = function (val) { };
    /**
     * @param {?} actionOrActions
     * @return {?}
     */
    StateOperations.prototype.dispatch = function (actionOrActions) { };
}
/**
 * @record
 */
export function MetaDataModel() { }
if (false) {
    /** @type {?} */
    MetaDataModel.prototype.name;
    /** @type {?} */
    MetaDataModel.prototype.actions;
    /** @type {?} */
    MetaDataModel.prototype.defaults;
    /** @type {?} */
    MetaDataModel.prototype.path;
    /** @type {?} */
    MetaDataModel.prototype.makeRootSelector;
    /** @type {?|undefined} */
    MetaDataModel.prototype.children;
}
/**
 * @record
 */
export function RuntimeSelectorContext() { }
if (false) {
    /**
     * @param {?} key
     * @return {?}
     */
    RuntimeSelectorContext.prototype.getStateGetter = function (key) { };
    /**
     * @param {?=} localOptions
     * @return {?}
     */
    RuntimeSelectorContext.prototype.getSelectorOptions = function (localOptions) { };
}
/**
 * @record
 */
export function SharedSelectorOptions() { }
if (false) {
    /** @type {?|undefined} */
    SharedSelectorOptions.prototype.injectContainerState;
    /** @type {?|undefined} */
    SharedSelectorOptions.prototype.suppressErrors;
}
/**
 * @record
 */
export function SelectorMetaDataModel() { }
if (false) {
    /** @type {?} */
    SelectorMetaDataModel.prototype.makeRootSelector;
    /** @type {?} */
    SelectorMetaDataModel.prototype.originalFn;
    /** @type {?} */
    SelectorMetaDataModel.prototype.containerClass;
    /** @type {?} */
    SelectorMetaDataModel.prototype.selectorName;
    /** @type {?} */
    SelectorMetaDataModel.prototype.getSelectorOptions;
}
/**
 * @record
 */
export function MappedStore() { }
if (false) {
    /** @type {?} */
    MappedStore.prototype.name;
    /** @type {?} */
    MappedStore.prototype.isInitialised;
    /** @type {?} */
    MappedStore.prototype.actions;
    /** @type {?} */
    MappedStore.prototype.defaults;
    /** @type {?} */
    MappedStore.prototype.instance;
    /** @type {?} */
    MappedStore.prototype.path;
}
/**
 * @record
 */
export function StatesAndDefaults() { }
if (false) {
    /** @type {?} */
    StatesAndDefaults.prototype.defaults;
    /** @type {?} */
    StatesAndDefaults.prototype.states;
}
/**
 * Ensures metadata is attached to the class and returns it.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
export function ensureStoreMetadata(target) {
    if (!target.hasOwnProperty(META_KEY)) {
        /** @type {?} */
        const defaultMetadata = {
            name: null,
            actions: {},
            defaults: {},
            path: null,
            /**
             * @param {?} context
             * @return {?}
             */
            makeRootSelector(context) {
                return context.getStateGetter(defaultMetadata.name);
            },
            children: []
        };
        Object.defineProperty(target, META_KEY, { value: defaultMetadata });
    }
    return getStoreMetadata(target);
}
/**
 * Get the metadata attached to the state class if it exists.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
export function getStoreMetadata(target) {
    return (/** @type {?} */ (target[META_KEY]));
}
/**
 * Ensures metadata is attached to the selector and returns it.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
export function ensureSelectorMetadata(target) {
    if (!target.hasOwnProperty(SELECTOR_META_KEY)) {
        /** @type {?} */
        const defaultMetadata = {
            makeRootSelector: null,
            originalFn: null,
            containerClass: null,
            selectorName: null,
            getSelectorOptions: (/**
             * @return {?}
             */
            () => ({}))
        };
        Object.defineProperty(target, SELECTOR_META_KEY, { value: defaultMetadata });
    }
    return getSelectorMetadata(target);
}
/**
 * Get the metadata attached to the selector if it exists.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
export function getSelectorMetadata(target) {
    return target[SELECTOR_META_KEY];
}
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.
 * See perf hit: https://jsperf.com/fast-value-getter-given-path/1
 *
 * @ignore
 * @param {?} paths
 * @return {?}
 */
function compliantPropGetter(paths) {
    /** @type {?} */
    const copyOfPaths = paths.slice();
    return (/**
     * @param {?} obj
     * @return {?}
     */
    obj => copyOfPaths.reduce((/**
     * @param {?} acc
     * @param {?} part
     * @return {?}
     */
    (acc, part) => acc && acc[part]), obj));
}
/**
 * The generated function is faster than:
 * - pluck (Observable operator)
 * - memoize
 *
 * @ignore
 * @param {?} paths
 * @return {?}
 */
function fastPropGetter(paths) {
    /** @type {?} */
    const segments = paths;
    /** @type {?} */
    let seg = 'store.' + segments[0];
    /** @type {?} */
    let i = 0;
    /** @type {?} */
    const l = segments.length;
    /** @type {?} */
    let expr = seg;
    while (++i < l) {
        expr = expr + ' && ' + (seg = seg + '.' + segments[i]);
    }
    /** @type {?} */
    const fn = new Function('store', 'return ' + expr + ';');
    return (/** @type {?} */ (fn));
}
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * @ignore
 * @param {?} paths
 * @param {?} config
 * @return {?}
 */
export function propGetter(paths, config) {
    if (config && config.compatibility && config.compatibility.strictContentSecurityPolicy) {
        return compliantPropGetter(paths);
    }
    else {
        return fastPropGetter(paths);
    }
}
/**
 * Given an array of states, it will return a object graph. Example:
 *    const states = [
 *      Cart,
 *      CartSaved,
 *      CartSavedItems
 *    ]
 *
 * would return:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * @ignore
 * @param {?} stateClasses
 * @return {?}
 */
export function buildGraph(stateClasses) {
    /** @type {?} */
    const findName = (/**
     * @param {?} stateClass
     * @return {?}
     */
    (stateClass) => {
        /** @type {?} */
        const meta = stateClasses.find((/**
         * @param {?} g
         * @return {?}
         */
        g => g === stateClass));
        // Caretaker note: we have still left the `typeof` condition in order to avoid
        // creating a breaking change for projects that still use the View Engine.
        if ((typeof ngDevMode === 'undefined' || ngDevMode) && !meta) {
            throw new Error(`Child state not found: ${stateClass}. \r\nYou may have forgotten to add states to module`);
        }
        return (/** @type {?} */ ((/** @type {?} */ ((/** @type {?} */ (meta))[META_KEY])).name));
    });
    return stateClasses.reduce((/**
     * @param {?} result
     * @param {?} stateClass
     * @return {?}
     */
    (result, stateClass) => {
        const { name, children } = (/** @type {?} */ (stateClass[META_KEY]));
        result[(/** @type {?} */ (name))] = (children || []).map(findName);
        return result;
    }), {});
}
/**
 * Given a states array, returns object graph
 * returning the name and state metadata. Example:
 *
 *  const graph = {
 *    cart: { metadata }
 *  };
 *
 * @ignore
 * @param {?} states
 * @return {?}
 */
export function nameToState(states) {
    return states.reduce((/**
     * @param {?} result
     * @param {?} stateClass
     * @return {?}
     */
    (result, stateClass) => {
        /** @type {?} */
        const meta = (/** @type {?} */ (stateClass[META_KEY]));
        result[(/** @type {?} */ (meta.name))] = stateClass;
        return result;
    }), {});
}
/**
 * Given a object relationship graph will return the full path
 * for the child items. Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const r = {
 *    cart: 'cart',
 *    saved: 'cart.saved',
 *    items: 'cart.saved.items'
 *  };
 *
 * @ignore
 * @param {?} obj
 * @param {?=} newObj
 * @return {?}
 */
export function findFullParentPath(obj, newObj = {}) {
    /** @type {?} */
    const visit = (/**
     * @param {?} child
     * @param {?} keyToFind
     * @return {?}
     */
    (child, keyToFind) => {
        for (const key in child) {
            if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {
                /** @type {?} */
                const parent = visit(child, key);
                return parent !== null ? `${parent}.${key}` : key;
            }
        }
        return null;
    });
    for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
            /** @type {?} */
            const parent = visit(obj, key);
            newObj[key] = parent ? `${parent}.${key}` : key;
        }
    }
    return newObj;
}
/**
 * Given a object graph, it will return the items topologically sorted Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const results = [
 *    'items',
 *    'saved',
 *    'cart'
 *  ];
 *
 * @ignore
 * @param {?} graph
 * @return {?}
 */
export function topologicalSort(graph) {
    /** @type {?} */
    const sorted = [];
    /** @type {?} */
    const visited = {};
    /** @type {?} */
    const visit = (/**
     * @param {?} name
     * @param {?=} ancestors
     * @return {?}
     */
    (name, ancestors = []) => {
        if (!Array.isArray(ancestors)) {
            ancestors = [];
        }
        ancestors.push(name);
        visited[name] = true;
        graph[name].forEach((/**
         * @param {?} dep
         * @return {?}
         */
        (dep) => {
            // Caretaker note: we have still left the `typeof` condition in order to avoid
            // creating a breaking change for projects that still use the View Engine.
            if ((typeof ngDevMode === 'undefined' || ngDevMode) && ancestors.indexOf(dep) >= 0) {
                throw new Error(`Circular dependency '${dep}' is required by '${name}': ${ancestors.join(' -> ')}`);
            }
            if (visited[dep]) {
                return;
            }
            visit(dep, ancestors.slice(0));
        }));
        if (sorted.indexOf(name) < 0) {
            sorted.push(name);
        }
    });
    Object.keys(graph).forEach((/**
     * @param {?} k
     * @return {?}
     */
    k => visit(k)));
    return sorted.reverse();
}
/**
 * Returns if the parameter is a object or not.
 *
 * @ignore
 * @param {?} obj
 * @return {?}
 */
export function isObject(obj) {
    return (typeof obj === 'object' && obj !== null) || typeof obj === 'function';
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJuYWxzLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG5neHMvc3RvcmUvIiwic291cmNlcyI6WyJzcmMvaW50ZXJuYWwvaW50ZXJuYWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFHQSxPQUFPLEVBQ0wsUUFBUSxFQUNSLGdCQUFnQixFQUVoQixpQkFBaUIsRUFFbEIsTUFBTSxZQUFZLENBQUM7Ozs7O0FBSXBCLHdDQUdDOzs7Ozs7Ozs7OztBQUtELHFDQU1DOzs7OztJQUxDLHFEQUFjOzs7OztJQUVkLHdEQUFvQjs7Ozs7SUFFcEIsb0VBQXlEOzs7OztBQUczRCxtQ0FPQzs7O0lBTkMsNkJBQW9COztJQUNwQixnQ0FBZ0Q7O0lBQ2hELGlDQUFjOztJQUNkLDZCQUFvQjs7SUFDcEIseUNBQXlDOztJQUN6QyxpQ0FBZ0M7Ozs7O0FBR2xDLDRDQUdDOzs7Ozs7SUFGQyxxRUFBOEM7Ozs7O0lBQzlDLGtGQUFnRjs7Ozs7QUFNbEYsMkNBR0M7OztJQUZDLHFEQUErQjs7SUFDL0IsK0NBQXlCOzs7OztBQUczQiwyQ0FNQzs7O0lBTEMsaURBQXlDOztJQUN6QywyQ0FBNEI7O0lBQzVCLCtDQUFvQjs7SUFDcEIsNkNBQTRCOztJQUM1QixtREFBZ0Q7Ozs7O0FBR2xELGlDQU9DOzs7SUFOQywyQkFBYTs7SUFDYixvQ0FBdUI7O0lBQ3ZCLDhCQUFnRDs7SUFDaEQsK0JBQWM7O0lBQ2QsK0JBQWM7O0lBQ2QsMkJBQWE7Ozs7O0FBR2YsdUNBR0M7OztJQUZDLHFDQUFjOztJQUNkLG1DQUFzQjs7Ozs7Ozs7O0FBUXhCLE1BQU0sVUFBVSxtQkFBbUIsQ0FBQyxNQUEwQjtJQUM1RCxJQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsRUFBRTs7Y0FDOUIsZUFBZSxHQUFrQjtZQUNyQyxJQUFJLEVBQUUsSUFBSTtZQUNWLE9BQU8sRUFBRSxFQUFFO1lBQ1gsUUFBUSxFQUFFLEVBQUU7WUFDWixJQUFJLEVBQUUsSUFBSTs7Ozs7WUFDVixn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O0lBQy9CLE9BQU8sQ0FBQyxPQUFPLEdBQUcsS0FBSyxRQUFRLElBQUksR0FBRyxLQUFLLElBQUksQ0FBQyxJQUFJLE9BQU8sR0FBRyxLQUFLLFVBQVUsQ0FBQztBQUNoRixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGxhaW5PYmplY3RPZiwgU3RhdGVDbGFzcyB9IGZyb20gJ0BuZ3hzL3N0b3JlL2ludGVybmFscyc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7XG4gIE1FVEFfS0VZLFxuICBNRVRBX09QVElPTlNfS0VZLFxuICBOZ3hzQ29uZmlnLFxuICBTRUxFQ1RPUl9NRVRBX0tFWSxcbiAgU3RvcmVPcHRpb25zXG59IGZyb20gJy4uL3N5bWJvbHMnO1xuaW1wb3J0IHsgQWN0aW9uSGFuZGxlck1ldGFEYXRhIH0gZnJvbSAnLi4vYWN0aW9ucy9zeW1ib2xzJztcblxuLy8gaW5zcGlyZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDM2NzQzODlcbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGVDbGFzc0ludGVybmFsPFQgPSBhbnksIFUgPSBhbnk+IGV4dGVuZHMgU3RhdGVDbGFzczxUPiB7XG4gIFtNRVRBX0tFWV0/OiBNZXRhRGF0YU1vZGVsO1xuICBbTUVUQV9PUFRJT05TX0tFWV0/OiBTdG9yZU9wdGlvbnM8VT47XG59XG5cbmV4cG9ydCB0eXBlIFN0YXRlS2V5R3JhcGggPSBQbGFpbk9iamVjdE9mPHN0cmluZ1tdPjtcbmV4cG9ydCB0eXBlIFN0YXRlc0J5TmFtZSA9IFBsYWluT2JqZWN0T2Y8U3RhdGVDbGFzc0ludGVybmFsPjtcblxuZXhwb3J0IGludGVyZmFjZSBTdGF0ZU9wZXJhdGlvbnM8VD4ge1xuICBnZXRTdGF0ZSgpOiBUO1xuXG4gIHNldFN0YXRlKHZhbDogVCk6IFQ7XG5cbiAgZGlzcGF0Y2goYWN0aW9uT3JBY3Rpb25zOiBhbnkgfCBhbnlbXSk6IE9ic2VydmFibGU8dm9pZD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWV0YURhdGFNb2RlbCB7XG4gIG5hbWU6IHN0cmluZyB8IG51bGw7XG4gIGFjdGlvbnM6IFBsYWluT2JqZWN0T2Y8QWN0aW9uSGFuZGxlck1ldGFEYXRhW10+O1xuICBkZWZhdWx0czogYW55O1xuICBwYXRoOiBzdHJpbmcgfCBudWxsO1xuICBtYWtlUm9vdFNlbGVjdG9yOiBTZWxlY3RvckZhY3RvcnkgfCBudWxsO1xuICBjaGlsZHJlbj86IFN0YXRlQ2xhc3NJbnRlcm5hbFtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJ1bnRpbWVTZWxlY3RvckNvbnRleHQge1xuICBnZXRTdGF0ZUdldHRlcihrZXk6IGFueSk6IChzdGF0ZTogYW55KSA9PiBhbnk7XG4gIGdldFNlbGVjdG9yT3B0aW9ucyhsb2NhbE9wdGlvbnM/OiBTaGFyZWRTZWxlY3Rvck9wdGlvbnMpOiBTaGFyZWRTZWxlY3Rvck9wdGlvbnM7XG59XG5cbmV4cG9ydCB0eXBlIFNlbGVjdEZyb21Sb290U3RhdGUgPSAocm9vdFN0YXRlOiBhbnkpID0+IGFueTtcbmV4cG9ydCB0eXBlIFNlbGVjdG9yRmFjdG9yeSA9IChydW50aW1lQ29udGV4dDogUnVudGltZVNlbGVjdG9yQ29udGV4dCkgPT4gU2VsZWN0RnJvbVJvb3RTdGF0ZTtcblxuZXhwb3J0IGludGVyZmFjZSBTaGFyZWRTZWxlY3Rvck9wdGlvbnMge1xuICBpbmplY3RDb250YWluZXJTdGF0ZT86IGJvb2xlYW47XG4gIHN1cHByZXNzRXJyb3JzPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZWxlY3Rvck1ldGFEYXRhTW9kZWwge1xuICBtYWtlUm9vdFNlbGVjdG9yOiBTZWxlY3RvckZhY3RvcnkgfCBudWxsO1xuICBvcmlnaW5hbEZuOiBGdW5jdGlvbiB8IG51bGw7XG4gIGNvbnRhaW5lckNsYXNzOiBhbnk7XG4gIHNlbGVjdG9yTmFtZTogc3RyaW5nIHwgbnVsbDtcbiAgZ2V0U2VsZWN0b3JPcHRpb25zOiAoKSA9PiBTaGFyZWRTZWxlY3Rvck9wdGlvbnM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFwcGVkU3RvcmUge1xuICBuYW1lOiBzdHJpbmc7XG4gIGlzSW5pdGlhbGlzZWQ6IGJvb2xlYW47XG4gIGFjdGlvbnM6IFBsYWluT2JqZWN0T2Y8QWN0aW9uSGFuZGxlck1ldGFEYXRhW10+O1xuICBkZWZhdWx0czogYW55O1xuICBpbnN0YW5jZTogYW55O1xuICBwYXRoOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGVzQW5kRGVmYXVsdHMge1xuICBkZWZhdWx0czogYW55O1xuICBzdGF0ZXM6IE1hcHBlZFN0b3JlW107XG59XG5cbi8qKlxuICogRW5zdXJlcyBtZXRhZGF0YSBpcyBhdHRhY2hlZCB0byB0aGUgY2xhc3MgYW5kIHJldHVybnMgaXQuXG4gKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlU3RvcmVNZXRhZGF0YSh0YXJnZXQ6IFN0YXRlQ2xhc3NJbnRlcm5hbCk6IE1ldGFEYXRhTW9kZWwge1xuICBpZiAoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShNRVRBX0tFWSkpIHtcbiAgICBjb25zdCBkZWZhdWx0TWV0YWRhdGE6IE1ldGFEYXRhTW9kZWwgPSB7XG4gICAgICBuYW1lOiBudWxsLFxuICAgICAgYWN0aW9uczoge30sXG4gICAgICBkZWZhdWx0czoge30sXG4gICAgICBwYXRoOiBudWxsLFxuICAgICAgbWFrZVJvb3RTZWxlY3Rvcihjb250ZXh0OiBSdW50aW1lU2VsZWN0b3JDb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmdldFN0YXRlR2V0dGVyKGRlZmF1bHRNZXRhZGF0YS5uYW1lKTtcbiAgICAgIH0sXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9O1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgTUVUQV9LRVksIHsgdmFsdWU6IGRlZmF1bHRNZXRhZGF0YSB9KTtcbiAgfVxuICByZXR1cm4gZ2V0U3RvcmVNZXRhZGF0YSh0YXJnZXQpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbWV0YWRhdGEgYXR0YWNoZWQgdG8gdGhlIHN0YXRlIGNsYXNzIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdG9yZU1ldGFkYXRhKHRhcmdldDogU3RhdGVDbGFzc0ludGVybmFsKTogTWV0YURhdGFNb2RlbCB7XG4gIHJldHVybiB0YXJnZXRbTUVUQV9LRVldITtcbn1cblxuLyoqXG4gKiBFbnN1cmVzIG1ldGFkYXRhIGlzIGF0dGFjaGVkIHRvIHRoZSBzZWxlY3RvciBhbmQgcmV0dXJucyBpdC5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVTZWxlY3Rvck1ldGFkYXRhKHRhcmdldDogRnVuY3Rpb24pOiBTZWxlY3Rvck1ldGFEYXRhTW9kZWwge1xuICBpZiAoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShTRUxFQ1RPUl9NRVRBX0tFWSkpIHtcbiAgICBjb25zdCBkZWZhdWx0TWV0YWRhdGE6IFNlbGVjdG9yTWV0YURhdGFNb2RlbCA9IHtcbiAgICAgIG1ha2VSb290U2VsZWN0b3I6IG51bGwsXG4gICAgICBvcmlnaW5hbEZuOiBudWxsLFxuICAgICAgY29udGFpbmVyQ2xhc3M6IG51bGwsXG4gICAgICBzZWxlY3Rvck5hbWU6IG51bGwsXG4gICAgICBnZXRTZWxlY3Rvck9wdGlvbnM6ICgpID0+ICh7fSlcbiAgICB9O1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgU0VMRUNUT1JfTUVUQV9LRVksIHsgdmFsdWU6IGRlZmF1bHRNZXRhZGF0YSB9KTtcbiAgfVxuXG4gIHJldHVybiBnZXRTZWxlY3Rvck1ldGFkYXRhKHRhcmdldCk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBtZXRhZGF0YSBhdHRhY2hlZCB0byB0aGUgc2VsZWN0b3IgaWYgaXQgZXhpc3RzLlxuICpcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNlbGVjdG9yTWV0YWRhdGEodGFyZ2V0OiBhbnkpOiBTZWxlY3Rvck1ldGFEYXRhTW9kZWwge1xuICByZXR1cm4gdGFyZ2V0W1NFTEVDVE9SX01FVEFfS0VZXTtcbn1cblxuLyoqXG4gKiBHZXQgYSBkZWVwbHkgbmVzdGVkIHZhbHVlLiBFeGFtcGxlOlxuICpcbiAqICAgIGdldFZhbHVlKHsgZm9vOiBiYXI6IFtdIH0sICdmb28uYmFyJykgLy89PiBbXVxuICpcbiAqIE5vdGU6IFRoaXMgaXMgbm90IGFzIGZhc3QgYXMgdGhlIGBmYXN0UHJvcEdldHRlcmAgYnV0IGlzIHN0cmljdCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBjb21wbGlhbnQuXG4gKiBTZWUgcGVyZiBoaXQ6IGh0dHBzOi8vanNwZXJmLmNvbS9mYXN0LXZhbHVlLWdldHRlci1naXZlbi1wYXRoLzFcbiAqXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIGNvbXBsaWFudFByb3BHZXR0ZXIocGF0aHM6IHN0cmluZ1tdKTogKHg6IGFueSkgPT4gYW55IHtcbiAgY29uc3QgY29weU9mUGF0aHMgPSBwYXRocy5zbGljZSgpO1xuICByZXR1cm4gb2JqID0+IGNvcHlPZlBhdGhzLnJlZHVjZSgoYWNjOiBhbnksIHBhcnQ6IHN0cmluZykgPT4gYWNjICYmIGFjY1twYXJ0XSwgb2JqKTtcbn1cblxuLyoqXG4gKiBUaGUgZ2VuZXJhdGVkIGZ1bmN0aW9uIGlzIGZhc3RlciB0aGFuOlxuICogLSBwbHVjayAoT2JzZXJ2YWJsZSBvcGVyYXRvcilcbiAqIC0gbWVtb2l6ZVxuICpcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gZmFzdFByb3BHZXR0ZXIocGF0aHM6IHN0cmluZ1tdKTogKHg6IGFueSkgPT4gYW55IHtcbiAgY29uc3Qgc2VnbWVudHMgPSBwYXRocztcbiAgbGV0IHNlZyA9ICdzdG9yZS4nICsgc2VnbWVudHNbMF07XG4gIGxldCBpID0gMDtcbiAgY29uc3QgbCA9IHNlZ21lbnRzLmxlbmd0aDtcblxuICBsZXQgZXhwciA9IHNlZztcbiAgd2hpbGUgKCsraSA8IGwpIHtcbiAgICBleHByID0gZXhwciArICcgJiYgJyArIChzZWcgPSBzZWcgKyAnLicgKyBzZWdtZW50c1tpXSk7XG4gIH1cblxuICBjb25zdCBmbiA9IG5ldyBGdW5jdGlvbignc3RvcmUnLCAncmV0dXJuICcgKyBleHByICsgJzsnKTtcblxuICByZXR1cm4gPCh4OiBhbnkpID0+IGFueT5mbjtcbn1cblxuLyoqXG4gKiBHZXQgYSBkZWVwbHkgbmVzdGVkIHZhbHVlLiBFeGFtcGxlOlxuICpcbiAqICAgIGdldFZhbHVlKHsgZm9vOiBiYXI6IFtdIH0sICdmb28uYmFyJykgLy89PiBbXVxuICpcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb3BHZXR0ZXIocGF0aHM6IHN0cmluZ1tdLCBjb25maWc6IE5neHNDb25maWcpIHtcbiAgaWYgKGNvbmZpZyAmJiBjb25maWcuY29tcGF0aWJpbGl0eSAmJiBjb25maWcuY29tcGF0aWJpbGl0eS5zdHJpY3RDb250ZW50U2VjdXJpdHlQb2xpY3kpIHtcbiAgICByZXR1cm4gY29tcGxpYW50UHJvcEdldHRlcihwYXRocyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhc3RQcm9wR2V0dGVyKHBhdGhzKTtcbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGFuIGFycmF5IG9mIHN0YXRlcywgaXQgd2lsbCByZXR1cm4gYSBvYmplY3QgZ3JhcGguIEV4YW1wbGU6XG4gKiAgICBjb25zdCBzdGF0ZXMgPSBbXG4gKiAgICAgIENhcnQsXG4gKiAgICAgIENhcnRTYXZlZCxcbiAqICAgICAgQ2FydFNhdmVkSXRlbXNcbiAqICAgIF1cbiAqXG4gKiB3b3VsZCByZXR1cm46XG4gKlxuICogIGNvbnN0IGdyYXBoID0ge1xuICogICAgY2FydDogWydzYXZlZCddLFxuICogICAgc2F2ZWQ6IFsnaXRlbXMnXSxcbiAqICAgIGl0ZW1zOiBbXVxuICogIH07XG4gKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRHcmFwaChzdGF0ZUNsYXNzZXM6IFN0YXRlQ2xhc3NJbnRlcm5hbFtdKTogU3RhdGVLZXlHcmFwaCB7XG4gIGNvbnN0IGZpbmROYW1lID0gKHN0YXRlQ2xhc3M6IFN0YXRlQ2xhc3NJbnRlcm5hbCkgPT4ge1xuICAgIGNvbnN0IG1ldGEgPSBzdGF0ZUNsYXNzZXMuZmluZChnID0+IGcgPT09IHN0YXRlQ2xhc3MpO1xuXG4gICAgLy8gQ2FyZXRha2VyIG5vdGU6IHdlIGhhdmUgc3RpbGwgbGVmdCB0aGUgYHR5cGVvZmAgY29uZGl0aW9uIGluIG9yZGVyIHRvIGF2b2lkXG4gICAgLy8gY3JlYXRpbmcgYSBicmVha2luZyBjaGFuZ2UgZm9yIHByb2plY3RzIHRoYXQgc3RpbGwgdXNlIHRoZSBWaWV3IEVuZ2luZS5cbiAgICBpZiAoKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkgJiYgIW1ldGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENoaWxkIHN0YXRlIG5vdCBmb3VuZDogJHtzdGF0ZUNsYXNzfS4gXFxyXFxuWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBhZGQgc3RhdGVzIHRvIG1vZHVsZWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ldGEhW01FVEFfS0VZXSEubmFtZSE7XG4gIH07XG5cbiAgcmV0dXJuIHN0YXRlQ2xhc3Nlcy5yZWR1Y2U8U3RhdGVLZXlHcmFwaD4oXG4gICAgKHJlc3VsdDogU3RhdGVLZXlHcmFwaCwgc3RhdGVDbGFzczogU3RhdGVDbGFzc0ludGVybmFsKSA9PiB7XG4gICAgICBjb25zdCB7IG5hbWUsIGNoaWxkcmVuIH0gPSBzdGF0ZUNsYXNzW01FVEFfS0VZXSE7XG4gICAgICByZXN1bHRbbmFtZSFdID0gKGNoaWxkcmVuIHx8IFtdKS5tYXAoZmluZE5hbWUpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIHt9XG4gICk7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBzdGF0ZXMgYXJyYXksIHJldHVybnMgb2JqZWN0IGdyYXBoXG4gKiByZXR1cm5pbmcgdGhlIG5hbWUgYW5kIHN0YXRlIG1ldGFkYXRhLiBFeGFtcGxlOlxuICpcbiAqICBjb25zdCBncmFwaCA9IHtcbiAqICAgIGNhcnQ6IHsgbWV0YWRhdGEgfVxuICogIH07XG4gKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbmFtZVRvU3RhdGUoc3RhdGVzOiBTdGF0ZUNsYXNzSW50ZXJuYWxbXSk6IFBsYWluT2JqZWN0T2Y8U3RhdGVDbGFzc0ludGVybmFsPiB7XG4gIHJldHVybiBzdGF0ZXMucmVkdWNlPFBsYWluT2JqZWN0T2Y8U3RhdGVDbGFzc0ludGVybmFsPj4oXG4gICAgKHJlc3VsdDogUGxhaW5PYmplY3RPZjxTdGF0ZUNsYXNzSW50ZXJuYWw+LCBzdGF0ZUNsYXNzOiBTdGF0ZUNsYXNzSW50ZXJuYWwpID0+IHtcbiAgICAgIGNvbnN0IG1ldGEgPSBzdGF0ZUNsYXNzW01FVEFfS0VZXSE7XG4gICAgICByZXN1bHRbbWV0YS5uYW1lIV0gPSBzdGF0ZUNsYXNzO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIHt9XG4gICk7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBvYmplY3QgcmVsYXRpb25zaGlwIGdyYXBoIHdpbGwgcmV0dXJuIHRoZSBmdWxsIHBhdGhcbiAqIGZvciB0aGUgY2hpbGQgaXRlbXMuIEV4YW1wbGU6XG4gKlxuICogIGNvbnN0IGdyYXBoID0ge1xuICogICAgY2FydDogWydzYXZlZCddLFxuICogICAgc2F2ZWQ6IFsnaXRlbXMnXSxcbiAqICAgIGl0ZW1zOiBbXVxuICogIH07XG4gKlxuICogd291bGQgcmV0dXJuOlxuICpcbiAqICBjb25zdCByID0ge1xuICogICAgY2FydDogJ2NhcnQnLFxuICogICAgc2F2ZWQ6ICdjYXJ0LnNhdmVkJyxcbiAqICAgIGl0ZW1zOiAnY2FydC5zYXZlZC5pdGVtcydcbiAqICB9O1xuICpcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRGdWxsUGFyZW50UGF0aChcbiAgb2JqOiBTdGF0ZUtleUdyYXBoLFxuICBuZXdPYmo6IFBsYWluT2JqZWN0T2Y8c3RyaW5nPiA9IHt9XG4pOiBQbGFpbk9iamVjdE9mPHN0cmluZz4ge1xuICBjb25zdCB2aXNpdCA9IChjaGlsZDogU3RhdGVLZXlHcmFwaCwga2V5VG9GaW5kOiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsID0+IHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkLmhhc093blByb3BlcnR5KGtleSkgJiYgY2hpbGRba2V5XS5pbmRleE9mKGtleVRvRmluZCkgPj0gMCkge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSB2aXNpdChjaGlsZCwga2V5KTtcbiAgICAgICAgcmV0dXJuIHBhcmVudCAhPT0gbnVsbCA/IGAke3BhcmVudH0uJHtrZXl9YCA6IGtleTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSB2aXNpdChvYmosIGtleSk7XG4gICAgICBuZXdPYmpba2V5XSA9IHBhcmVudCA/IGAke3BhcmVudH0uJHtrZXl9YCA6IGtleTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3T2JqO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgb2JqZWN0IGdyYXBoLCBpdCB3aWxsIHJldHVybiB0aGUgaXRlbXMgdG9wb2xvZ2ljYWxseSBzb3J0ZWQgRXhhbXBsZTpcbiAqXG4gKiAgY29uc3QgZ3JhcGggPSB7XG4gKiAgICBjYXJ0OiBbJ3NhdmVkJ10sXG4gKiAgICBzYXZlZDogWydpdGVtcyddLFxuICogICAgaXRlbXM6IFtdXG4gKiAgfTtcbiAqXG4gKiB3b3VsZCByZXR1cm46XG4gKlxuICogIGNvbnN0IHJlc3VsdHMgPSBbXG4gKiAgICAnaXRlbXMnLFxuICogICAgJ3NhdmVkJyxcbiAqICAgICdjYXJ0J1xuICogIF07XG4gKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9wb2xvZ2ljYWxTb3J0KGdyYXBoOiBTdGF0ZUtleUdyYXBoKTogc3RyaW5nW10ge1xuICBjb25zdCBzb3J0ZWQ6IHN0cmluZ1tdID0gW107XG4gIGNvbnN0IHZpc2l0ZWQ6IFBsYWluT2JqZWN0T2Y8Ym9vbGVhbj4gPSB7fTtcblxuICBjb25zdCB2aXNpdCA9IChuYW1lOiBzdHJpbmcsIGFuY2VzdG9yczogc3RyaW5nW10gPSBbXSkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhbmNlc3RvcnMpKSB7XG4gICAgICBhbmNlc3RvcnMgPSBbXTtcbiAgICB9XG5cbiAgICBhbmNlc3RvcnMucHVzaChuYW1lKTtcbiAgICB2aXNpdGVkW25hbWVdID0gdHJ1ZTtcblxuICAgIGdyYXBoW25hbWVdLmZvckVhY2goKGRlcDogc3RyaW5nKSA9PiB7XG4gICAgICAvLyBDYXJldGFrZXIgbm90ZTogd2UgaGF2ZSBzdGlsbCBsZWZ0IHRoZSBgdHlwZW9mYCBjb25kaXRpb24gaW4gb3JkZXIgdG8gYXZvaWRcbiAgICAgIC8vIGNyZWF0aW5nIGEgYnJlYWtpbmcgY2hhbmdlIGZvciBwcm9qZWN0cyB0aGF0IHN0aWxsIHVzZSB0aGUgVmlldyBFbmdpbmUuXG4gICAgICBpZiAoKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkgJiYgYW5jZXN0b3JzLmluZGV4T2YoZGVwKSA+PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQ2lyY3VsYXIgZGVwZW5kZW5jeSAnJHtkZXB9JyBpcyByZXF1aXJlZCBieSAnJHtuYW1lfSc6ICR7YW5jZXN0b3JzLmpvaW4oJyAtPiAnKX1gXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2aXNpdGVkW2RlcF0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2aXNpdChkZXAsIGFuY2VzdG9ycy5zbGljZSgwKSk7XG4gICAgfSk7XG5cbiAgICBpZiAoc29ydGVkLmluZGV4T2YobmFtZSkgPCAwKSB7XG4gICAgICBzb3J0ZWQucHVzaChuYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgT2JqZWN0LmtleXMoZ3JhcGgpLmZvckVhY2goayA9PiB2aXNpdChrKSk7XG5cbiAgcmV0dXJuIHNvcnRlZC5yZXZlcnNlKCk7XG59XG5cbi8qKlxuICogUmV0dXJucyBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgb2JqZWN0IG9yIG5vdC5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdChvYmo6IGFueSkge1xuICByZXR1cm4gKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCkgfHwgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJztcbn1cbiJdfQ==