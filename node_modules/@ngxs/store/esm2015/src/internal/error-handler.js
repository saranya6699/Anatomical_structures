/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ErrorHandler, Injectable, Injector } from '@angular/core';
import { Observable } from 'rxjs';
import { leaveNgxs } from '../operators/leave-ngxs';
import * as i0 from "@angular/core";
/**
 * This operator is used for piping the observable result
 * from the `dispatch()`. It has a "smart" error handling
 * strategy that allows us to decide whether we propagate
 * errors to Angular's `ErrorHandler` or enable users to
 * handle them manually. We consider following cases:
 * 1) `store.dispatch()` (no subscribe) -> call `handleError()`
 * 2) `store.dispatch().subscribe()` (no error callback) -> call `handleError()`
 * 3) `store.dispatch().subscribe({ error: ... })` -> don't call `handleError()`
 * 4) `toPromise()` without `catch` -> do `handleError()`
 * 5) `toPromise()` with `catch` -> don't `handleError()`
 * @template T
 * @param {?} internalErrorReporter
 * @param {?} ngxsExecutionStrategy
 * @return {?}
 */
export function ngxsErrorHandler(internalErrorReporter, ngxsExecutionStrategy) {
    return (/**
     * @param {?} source
     * @return {?}
     */
    (source) => {
        /** @type {?} */
        let subscribed = false;
        source.subscribe({
            error: (/**
             * @param {?} error
             * @return {?}
             */
            error => {
                // Do not trigger change detection for a microtask. This depends on the execution
                // strategy being used, but the default `DispatchOutsideZoneNgxsExecutionStrategy`
                // leaves the Angular zone.
                ngxsExecutionStrategy.enter((/**
                 * @return {?}
                 */
                () => Promise.resolve().then((/**
                 * @return {?}
                 */
                () => {
                    if (!subscribed) {
                        ngxsExecutionStrategy.leave((/**
                         * @return {?}
                         */
                        () => internalErrorReporter.reportErrorSafely(error)));
                    }
                }))));
            })
        });
        return new Observable((/**
         * @param {?} subscriber
         * @return {?}
         */
        subscriber => {
            subscribed = true;
            return source.pipe(leaveNgxs(ngxsExecutionStrategy)).subscribe(subscriber);
        }));
    });
}
export class InternalErrorReporter {
    /**
     * @param {?} _injector
     */
    constructor(_injector) {
        this._injector = _injector;
        /**
         * Will be set lazily to be backward compatible.
         */
        this._errorHandler = (/** @type {?} */ (null));
    }
    /**
     * @param {?} error
     * @return {?}
     */
    reportErrorSafely(error) {
        if (this._errorHandler === null) {
            this._errorHandler = this._injector.get(ErrorHandler);
        }
        // The `try-catch` is used to avoid handling the error twice. Suppose we call
        // `handleError` which re-throws the error internally. The re-thrown error will
        // be caught by zone.js which will then get to the `zone.onError.emit()` and the
        // `onError` subscriber will call `handleError` again.
        try {
            this._errorHandler.handleError(error);
        }
        catch (_a) { }
    }
}
InternalErrorReporter.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
InternalErrorReporter.ctorParameters = () => [
    { type: Injector }
];
/** @nocollapse */ InternalErrorReporter.ngInjectableDef = i0.defineInjectable({ factory: function InternalErrorReporter_Factory() { return new InternalErrorReporter(i0.inject(i0.INJECTOR)); }, token: InternalErrorReporter, providedIn: "root" });
if (false) {
    /**
     * Will be set lazily to be backward compatible.
     * @type {?}
     * @private
     */
    InternalErrorReporter.prototype._errorHandler;
    /**
     * @type {?}
     * @private
     */
    InternalErrorReporter.prototype._injector;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXJyb3ItaGFuZGxlci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuZ3hzL3N0b3JlLyIsInNvdXJjZXMiOlsic3JjL2ludGVybmFsL2Vycm9yLWhhbmRsZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxZQUFZLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNuRSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBRWxDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZXBELE1BQU0sVUFBVSxnQkFBZ0IsQ0FDOUIscUJBQTRDLEVBQzVDLHFCQUE0QztJQUU1Qzs7OztJQUFPLENBQUMsTUFBcUIsRUFBRSxFQUFFOztZQUMzQixVQUFVLEdBQUcsS0FBSztRQUV0QixNQUFNLENBQUMsU0FBUyxDQUFDO1lBQ2YsS0FBSzs7OztZQUFFLEtBQUssQ0FBQyxFQUFFO2dCQUNiLGlGQUFpRjtnQkFDakYsa0ZBQWtGO2dCQUNsRiwyQkFBMkI7Z0JBQzNCLHFCQUFxQixDQUFDLEtBQUs7OztnQkFBQyxHQUFHLEVBQUUsQ0FDL0IsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDLElBQUk7OztnQkFBQyxHQUFHLEVBQUU7b0JBQzFCLElBQUksQ0FBQyxVQUFVLEVBQUU7d0JBQ2YscUJBQXFCLENBQUMsS0FBSzs7O3dCQUFDLEdBQUcsRUFBRSxDQUMvQixxQkFBcUIsQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsRUFDL0MsQ0FBQztxQkFDSDtnQkFDSCxDQUFDLEVBQUMsRUFDSCxDQUFDO1lBQ0osQ0FBQyxDQUFBO1NBQ0YsQ0FBQyxDQUFDO1FBRUgsT0FBTyxJQUFJLFVBQVU7Ozs7UUFBQyxVQUFVLENBQUMsRUFBRTtZQUNqQyxVQUFVLEdBQUcsSUFBSSxDQUFDO1lBQ2xCLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMscUJBQXFCLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUM3RSxDQUFDLEVBQUMsQ0FBQztJQUNMLENBQUMsRUFBQztBQUNKLENBQUM7QUFHRCxNQUFNLE9BQU8scUJBQXFCOzs7O0lBSWhDLFlBQW9CLFNBQW1CO1FBQW5CLGNBQVMsR0FBVCxTQUFTLENBQVU7Ozs7UUFGL0Isa0JBQWEsR0FBaUIsbUJBQUEsSUFBSSxFQUFDLENBQUM7SUFFRixDQUFDOzs7OztJQUUzQyxpQkFBaUIsQ0FBQyxLQUFVO1FBQzFCLElBQUksSUFBSSxDQUFDLGFBQWEsS0FBSyxJQUFJLEVBQUU7WUFDL0IsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQztTQUN2RDtRQUNELDZFQUE2RTtRQUM3RSwrRUFBK0U7UUFDL0UsZ0ZBQWdGO1FBQ2hGLHNEQUFzRDtRQUN0RCxJQUFJO1lBQ0YsSUFBSSxDQUFDLGFBQWEsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDdkM7UUFBQyxXQUFNLEdBQUU7SUFDWixDQUFDOzs7WUFsQkYsVUFBVSxTQUFDLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRTs7OztZQWpEQyxRQUFROzs7Ozs7Ozs7SUFvRHpDLDhDQUE0Qzs7Ozs7SUFFaEMsMENBQTJCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXJyb3JIYW5kbGVyLCBJbmplY3RhYmxlLCBJbmplY3RvciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBsZWF2ZU5neHMgfSBmcm9tICcuLi9vcGVyYXRvcnMvbGVhdmUtbmd4cyc7XG5pbXBvcnQgeyBOZ3hzRXhlY3V0aW9uU3RyYXRlZ3kgfSBmcm9tICcuLi9leGVjdXRpb24vc3ltYm9scyc7XG5cbi8qKlxuICogVGhpcyBvcGVyYXRvciBpcyB1c2VkIGZvciBwaXBpbmcgdGhlIG9ic2VydmFibGUgcmVzdWx0XG4gKiBmcm9tIHRoZSBgZGlzcGF0Y2goKWAuIEl0IGhhcyBhIFwic21hcnRcIiBlcnJvciBoYW5kbGluZ1xuICogc3RyYXRlZ3kgdGhhdCBhbGxvd3MgdXMgdG8gZGVjaWRlIHdoZXRoZXIgd2UgcHJvcGFnYXRlXG4gKiBlcnJvcnMgdG8gQW5ndWxhcidzIGBFcnJvckhhbmRsZXJgIG9yIGVuYWJsZSB1c2VycyB0b1xuICogaGFuZGxlIHRoZW0gbWFudWFsbHkuIFdlIGNvbnNpZGVyIGZvbGxvd2luZyBjYXNlczpcbiAqIDEpIGBzdG9yZS5kaXNwYXRjaCgpYCAobm8gc3Vic2NyaWJlKSAtPiBjYWxsIGBoYW5kbGVFcnJvcigpYFxuICogMikgYHN0b3JlLmRpc3BhdGNoKCkuc3Vic2NyaWJlKClgIChubyBlcnJvciBjYWxsYmFjaykgLT4gY2FsbCBgaGFuZGxlRXJyb3IoKWBcbiAqIDMpIGBzdG9yZS5kaXNwYXRjaCgpLnN1YnNjcmliZSh7IGVycm9yOiAuLi4gfSlgIC0+IGRvbid0IGNhbGwgYGhhbmRsZUVycm9yKClgXG4gKiA0KSBgdG9Qcm9taXNlKClgIHdpdGhvdXQgYGNhdGNoYCAtPiBkbyBgaGFuZGxlRXJyb3IoKWBcbiAqIDUpIGB0b1Byb21pc2UoKWAgd2l0aCBgY2F0Y2hgIC0+IGRvbid0IGBoYW5kbGVFcnJvcigpYFxuICovXG5leHBvcnQgZnVuY3Rpb24gbmd4c0Vycm9ySGFuZGxlcjxUPihcbiAgaW50ZXJuYWxFcnJvclJlcG9ydGVyOiBJbnRlcm5hbEVycm9yUmVwb3J0ZXIsXG4gIG5neHNFeGVjdXRpb25TdHJhdGVneTogTmd4c0V4ZWN1dGlvblN0cmF0ZWd5XG4pIHtcbiAgcmV0dXJuIChzb3VyY2U6IE9ic2VydmFibGU8VD4pID0+IHtcbiAgICBsZXQgc3Vic2NyaWJlZCA9IGZhbHNlO1xuXG4gICAgc291cmNlLnN1YnNjcmliZSh7XG4gICAgICBlcnJvcjogZXJyb3IgPT4ge1xuICAgICAgICAvLyBEbyBub3QgdHJpZ2dlciBjaGFuZ2UgZGV0ZWN0aW9uIGZvciBhIG1pY3JvdGFzay4gVGhpcyBkZXBlbmRzIG9uIHRoZSBleGVjdXRpb25cbiAgICAgICAgLy8gc3RyYXRlZ3kgYmVpbmcgdXNlZCwgYnV0IHRoZSBkZWZhdWx0IGBEaXNwYXRjaE91dHNpZGVab25lTmd4c0V4ZWN1dGlvblN0cmF0ZWd5YFxuICAgICAgICAvLyBsZWF2ZXMgdGhlIEFuZ3VsYXIgem9uZS5cbiAgICAgICAgbmd4c0V4ZWN1dGlvblN0cmF0ZWd5LmVudGVyKCgpID0+XG4gICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgICAgbmd4c0V4ZWN1dGlvblN0cmF0ZWd5LmxlYXZlKCgpID0+XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxFcnJvclJlcG9ydGVyLnJlcG9ydEVycm9yU2FmZWx5KGVycm9yKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoc3Vic2NyaWJlciA9PiB7XG4gICAgICBzdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBzb3VyY2UucGlwZShsZWF2ZU5neHMobmd4c0V4ZWN1dGlvblN0cmF0ZWd5KSkuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgIH0pO1xuICB9O1xufVxuXG5ASW5qZWN0YWJsZSh7IHByb3ZpZGVkSW46ICdyb290JyB9KVxuZXhwb3J0IGNsYXNzIEludGVybmFsRXJyb3JSZXBvcnRlciB7XG4gIC8qKiBXaWxsIGJlIHNldCBsYXppbHkgdG8gYmUgYmFja3dhcmQgY29tcGF0aWJsZS4gKi9cbiAgcHJpdmF0ZSBfZXJyb3JIYW5kbGVyOiBFcnJvckhhbmRsZXIgPSBudWxsITtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9pbmplY3RvcjogSW5qZWN0b3IpIHt9XG5cbiAgcmVwb3J0RXJyb3JTYWZlbHkoZXJyb3I6IGFueSk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9lcnJvckhhbmRsZXIgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2Vycm9ySGFuZGxlciA9IHRoaXMuX2luamVjdG9yLmdldChFcnJvckhhbmRsZXIpO1xuICAgIH1cbiAgICAvLyBUaGUgYHRyeS1jYXRjaGAgaXMgdXNlZCB0byBhdm9pZCBoYW5kbGluZyB0aGUgZXJyb3IgdHdpY2UuIFN1cHBvc2Ugd2UgY2FsbFxuICAgIC8vIGBoYW5kbGVFcnJvcmAgd2hpY2ggcmUtdGhyb3dzIHRoZSBlcnJvciBpbnRlcm5hbGx5LiBUaGUgcmUtdGhyb3duIGVycm9yIHdpbGxcbiAgICAvLyBiZSBjYXVnaHQgYnkgem9uZS5qcyB3aGljaCB3aWxsIHRoZW4gZ2V0IHRvIHRoZSBgem9uZS5vbkVycm9yLmVtaXQoKWAgYW5kIHRoZVxuICAgIC8vIGBvbkVycm9yYCBzdWJzY3JpYmVyIHdpbGwgY2FsbCBgaGFuZGxlRXJyb3JgIGFnYWluLlxuICAgIHRyeSB7XG4gICAgICB0aGlzLl9lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgIH0gY2F0Y2gge31cbiAgfVxufVxuIl19