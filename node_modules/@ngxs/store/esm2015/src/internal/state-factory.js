/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable, Injector, Optional, SkipSelf, Inject } from '@angular/core';
import { forkJoin, from, of, throwError, Subject, isObservable } from 'rxjs';
import { catchError, defaultIfEmpty, filter, map, mergeMap, shareReplay, takeUntil } from 'rxjs/operators';
import { INITIAL_STATE_TOKEN, memoize } from '@ngxs/store/internals';
import { META_KEY, NgxsConfig } from '../symbols';
import { buildGraph, findFullParentPath, isObject, nameToState, propGetter, topologicalSort, getStoreMetadata } from './internals';
import { getActionTypeFromInstance, getValue, setValue } from '../utils/utils';
import { ofActionDispatched } from '../operators/of-action';
import { InternalActions } from '../actions-stream';
import { InternalDispatchedActionResults } from '../internal/dispatcher';
import { StateContextFactory } from '../internal/state-context-factory';
import { StoreValidators } from '../utils/store-validators';
import { ensureStateClassIsInjectable } from '../ivy/ivy-enabled-in-dev-mode';
/**
 * State factory class
 * @ignore
 */
export class StateFactory {
    /**
     * @param {?} _injector
     * @param {?} _config
     * @param {?} _parentFactory
     * @param {?} _actions
     * @param {?} _actionResults
     * @param {?} _stateContextFactory
     * @param {?} _initialState
     */
    constructor(_injector, _config, _parentFactory, _actions, _actionResults, _stateContextFactory, _initialState) {
        this._injector = _injector;
        this._config = _config;
        this._parentFactory = _parentFactory;
        this._actions = _actions;
        this._actionResults = _actionResults;
        this._stateContextFactory = _stateContextFactory;
        this._initialState = _initialState;
        this._actionsSubscription = null;
        this._states = [];
        this._statesByName = {};
        this._statePaths = {};
        this.getRuntimeSelectorContext = memoize((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const stateFactory = this;
            /**
             * @param {?} key
             * @return {?}
             */
            function resolveGetter(key) {
                /** @type {?} */
                const path = stateFactory.statePaths[key];
                return path ? propGetter(path.split('.'), stateFactory._config) : null;
            }
            /** @type {?} */
            const context = this._parentFactory
                ? this._parentFactory.getRuntimeSelectorContext()
                : {
                    /**
                     * @param {?} key
                     * @return {?}
                     */
                    getStateGetter(key) {
                        /** @type {?} */
                        let getter = resolveGetter(key);
                        if (getter) {
                            return getter;
                        }
                        return (/**
                         * @param {...?} args
                         * @return {?}
                         */
                        (...args) => {
                            // Late loaded getter
                            if (!getter) {
                                getter = resolveGetter(key);
                            }
                            return getter ? getter(...args) : undefined;
                        });
                    },
                    /**
                     * @param {?=} localOptions
                     * @return {?}
                     */
                    getSelectorOptions(localOptions) {
                        /** @type {?} */
                        const globalSelectorOptions = stateFactory._config.selectorOptions;
                        return Object.assign({}, globalSelectorOptions, (localOptions || {}));
                    }
                };
            return context;
        }));
    }
    /**
     * @return {?}
     */
    get states() {
        return this._parentFactory ? this._parentFactory.states : this._states;
    }
    /**
     * @return {?}
     */
    get statesByName() {
        return this._parentFactory ? this._parentFactory.statesByName : this._statesByName;
    }
    /**
     * @private
     * @return {?}
     */
    get statePaths() {
        return this._parentFactory ? this._parentFactory.statePaths : this._statePaths;
    }
    /**
     * @private
     * @param {?} defaults
     * @return {?}
     */
    static cloneDefaults(defaults) {
        /** @type {?} */
        let value = {};
        if (Array.isArray(defaults)) {
            value = defaults.slice();
        }
        else if (isObject(defaults)) {
            value = Object.assign({}, defaults);
        }
        else if (defaults === undefined) {
            value = {};
        }
        else {
            value = defaults;
        }
        return value;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // I'm using non-null assertion here since `_actionsSubscrition` will
        // be 100% defined. This is because `ngOnDestroy()` cannot be invoked
        // on the `StateFactory` until its initialized :) An it's initialized
        // for the first time along with the `NgxsRootModule`.
        (/** @type {?} */ (this._actionsSubscription)).unsubscribe();
    }
    /**
     * Add a new state to the global defs.
     * @param {?} stateClasses
     * @return {?}
     */
    add(stateClasses) {
        // Caretaker note: we have still left the `typeof` condition in order to avoid
        // creating a breaking change for projects that still use the View Engine.
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
            StoreValidators.checkThatStateClassesHaveBeenDecorated(stateClasses);
        }
        const { newStates } = this.addToStatesMap(stateClasses);
        if (!newStates.length)
            return [];
        /** @type {?} */
        const stateGraph = buildGraph(newStates);
        /** @type {?} */
        const sortedStates = topologicalSort(stateGraph);
        /** @type {?} */
        const paths = findFullParentPath(stateGraph);
        /** @type {?} */
        const nameGraph = nameToState(newStates);
        /** @type {?} */
        const bootstrappedStores = [];
        for (const name of sortedStates) {
            /** @type {?} */
            const stateClass = nameGraph[name];
            /** @type {?} */
            const path = paths[name];
            /** @type {?} */
            const meta = (/** @type {?} */ (stateClass[META_KEY]));
            this.addRuntimeInfoToMeta(meta, path);
            // Note: previously we called `ensureStateClassIsInjectable` within the
            // `State` decorator. This check is moved here because the `Éµprov` property
            // will not exist on the class in JIT mode (because it's set asynchronously
            // during JIT compilation through `Object.defineProperty`).
            if (typeof ngDevMode === 'undefined' || ngDevMode) {
                ensureStateClassIsInjectable(stateClass);
            }
            /** @type {?} */
            const stateMap = {
                name,
                path,
                isInitialised: false,
                actions: meta.actions,
                instance: this._injector.get(stateClass),
                defaults: StateFactory.cloneDefaults(meta.defaults)
            };
            // ensure our store hasn't already been added
            // but don't throw since it could be lazy
            // loaded from different paths
            if (!this.hasBeenMountedAndBootstrapped(name, path)) {
                bootstrappedStores.push(stateMap);
            }
            this.states.push(stateMap);
        }
        return bootstrappedStores;
    }
    /**
     * Add a set of states to the store and return the defaults
     * @param {?} stateClasses
     * @return {?}
     */
    addAndReturnDefaults(stateClasses) {
        /** @type {?} */
        const classes = stateClasses || [];
        /** @type {?} */
        const mappedStores = this.add(classes);
        /** @type {?} */
        const defaults = mappedStores.reduce((/**
         * @param {?} result
         * @param {?} mappedStore
         * @return {?}
         */
        (result, mappedStore) => setValue(result, mappedStore.path, mappedStore.defaults)), {});
        return { defaults, states: mappedStores };
    }
    /**
     * Bind the actions to the handlers
     * @return {?}
     */
    connectActionHandlers() {
        if (this._actionsSubscription !== null)
            return;
        /** @type {?} */
        const dispatched$ = new Subject();
        this._actionsSubscription = this._actions
            .pipe(filter((/**
         * @param {?} ctx
         * @return {?}
         */
        (ctx) => ctx.status === "DISPATCHED" /* Dispatched */)), mergeMap((/**
         * @param {?} ctx
         * @return {?}
         */
        ctx => {
            dispatched$.next(ctx);
            /** @type {?} */
            const action = ctx.action;
            return this.invokeActions(dispatched$, (/** @type {?} */ (action))).pipe(map((/**
             * @return {?}
             */
            () => (/** @type {?} */ ({ action, status: "SUCCESSFUL" /* Successful */ })))), defaultIfEmpty((/** @type {?} */ ({ action, status: "CANCELED" /* Canceled */ }))), catchError((/**
             * @param {?} error
             * @return {?}
             */
            error => of((/** @type {?} */ ({ action, status: "ERRORED" /* Errored */, error }))))));
        })))
            .subscribe((/**
         * @param {?} ctx
         * @return {?}
         */
        ctx => this._actionResults.next(ctx)));
    }
    /**
     * Invoke actions on the states.
     * @param {?} dispatched$
     * @param {?} action
     * @return {?}
     */
    invokeActions(dispatched$, action) {
        /** @type {?} */
        const type = (/** @type {?} */ (getActionTypeFromInstance(action)));
        /** @type {?} */
        const results = [];
        for (const metadata of this.states) {
            /** @type {?} */
            const actionMetas = metadata.actions[type];
            if (actionMetas) {
                for (const actionMeta of actionMetas) {
                    /** @type {?} */
                    const stateContext = this._stateContextFactory.createStateContext(metadata);
                    try {
                        /** @type {?} */
                        let result = metadata.instance[actionMeta.fn](stateContext, action);
                        if (result instanceof Promise) {
                            result = from(result);
                        }
                        if (isObservable(result)) {
                            // If this observable has been completed w/o emitting
                            // any value then we wouldn't want to complete the whole chain
                            // of actions. Since if any observable completes then
                            // action will be canceled.
                            // For instance if any action handler would've had such statement:
                            // `handler(ctx) { return EMPTY; }`
                            // then the action will be canceled.
                            // See https://github.com/ngxs/store/issues/1568
                            result = result.pipe(mergeMap((/**
                             * @param {?} value
                             * @return {?}
                             */
                            (value) => {
                                if (value instanceof Promise) {
                                    return from(value);
                                }
                                if (isObservable(value)) {
                                    return value;
                                }
                                return of(value);
                            })), defaultIfEmpty({}));
                            if (actionMeta.options.cancelUncompleted) {
                                // todo: ofActionDispatched should be used with action class
                                result = result.pipe(takeUntil(dispatched$.pipe(ofActionDispatched((/** @type {?} */ (action))))));
                            }
                        }
                        else {
                            result = of({}).pipe(shareReplay());
                        }
                        results.push(result);
                    }
                    catch (e) {
                        results.push(throwError(e));
                    }
                }
            }
        }
        if (!results.length) {
            results.push(of({}));
        }
        return forkJoin(results);
    }
    /**
     * @private
     * @param {?} stateClasses
     * @return {?}
     */
    addToStatesMap(stateClasses) {
        /** @type {?} */
        const newStates = [];
        /** @type {?} */
        const statesMap = this.statesByName;
        for (const stateClass of stateClasses) {
            /** @type {?} */
            const stateName = (/** @type {?} */ (getStoreMetadata(stateClass).name));
            // Caretaker note: we have still left the `typeof` condition in order to avoid
            // creating a breaking change for projects that still use the View Engine.
            if (typeof ngDevMode === 'undefined' || ngDevMode) {
                StoreValidators.checkThatStateNameIsUnique(stateName, stateClass, statesMap);
            }
            /** @type {?} */
            const unmountedState = !statesMap[stateName];
            if (unmountedState) {
                newStates.push(stateClass);
                statesMap[stateName] = stateClass;
            }
        }
        return { newStates };
    }
    /**
     * @private
     * @param {?} meta
     * @param {?} path
     * @return {?}
     */
    addRuntimeInfoToMeta(meta, path) {
        this.statePaths[(/** @type {?} */ (meta.name))] = path;
        // TODO: v4 - we plan to get rid of the path property because it is non-deterministic
        // we can do this when we get rid of the incorrectly exposed getStoreMetadata
        // We will need to come up with an alternative in v4 because this is used by many plugins
        meta.path = path;
    }
    /**
     * \@description
     * the method checks if the state has already been added to the tree
     * and completed the life cycle
     * @private
     * @param {?} name
     * @param {?} path
     * @return {?}
     */
    hasBeenMountedAndBootstrapped(name, path) {
        /** @type {?} */
        const valueIsBootstrappedInInitialState = getValue(this._initialState, path) !== undefined;
        return this.statesByName[name] && valueIsBootstrappedInInitialState;
    }
}
StateFactory.decorators = [
    { type: Injectable }
];
/** @nocollapse */
StateFactory.ctorParameters = () => [
    { type: Injector },
    { type: NgxsConfig },
    { type: StateFactory, decorators: [{ type: Optional }, { type: SkipSelf }] },
    { type: InternalActions },
    { type: InternalDispatchedActionResults },
    { type: StateContextFactory },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [INITIAL_STATE_TOKEN,] }] }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._actionsSubscription;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._states;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._statesByName;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._statePaths;
    /** @type {?} */
    StateFactory.prototype.getRuntimeSelectorContext;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._injector;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._config;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._parentFactory;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._actions;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._actionResults;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._stateContextFactory;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._initialState;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGUtZmFjdG9yeS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuZ3hzL3N0b3JlLyIsInNvdXJjZXMiOlsic3JjL2ludGVybmFsL3N0YXRlLWZhY3RvcnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFhLE1BQU0sZUFBZSxDQUFDO0FBQzVGLE9BQU8sRUFDTCxRQUFRLEVBQ1IsSUFBSSxFQUVKLEVBQUUsRUFDRixVQUFVLEVBRVYsT0FBTyxFQUNQLFlBQVksRUFDYixNQUFNLE1BQU0sQ0FBQztBQUNkLE9BQU8sRUFDTCxVQUFVLEVBQ1YsY0FBYyxFQUNkLE1BQU0sRUFDTixHQUFHLEVBQ0gsUUFBUSxFQUNSLFdBQVcsRUFDWCxTQUFTLEVBQ1YsTUFBTSxnQkFBZ0IsQ0FBQztBQUN4QixPQUFPLEVBQUUsbUJBQW1CLEVBQWlCLE9BQU8sRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBRXBGLE9BQU8sRUFBRSxRQUFRLEVBQUUsVUFBVSxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBQ2xELE9BQU8sRUFDTCxVQUFVLEVBQ1Ysa0JBQWtCLEVBQ2xCLFFBQVEsRUFHUixXQUFXLEVBQ1gsVUFBVSxFQUtWLGVBQWUsRUFHZixnQkFBZ0IsRUFDakIsTUFBTSxhQUFhLENBQUM7QUFDckIsT0FBTyxFQUFFLHlCQUF5QixFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUMvRSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUM1RCxPQUFPLEVBQStCLGVBQWUsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ2pGLE9BQU8sRUFBRSwrQkFBK0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ3pFLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLG1DQUFtQyxDQUFDO0FBQ3hFLE9BQU8sRUFBRSxlQUFlLEVBQUUs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LDRDQUF5RDs7Ozs7SUFnQnpELCtCQUFvQzs7Ozs7SUFNcEMscUNBQXlDOzs7OztJQU16QyxtQ0FBZ0Q7O0lBTWhELGlEQWlDRzs7Ozs7SUFoRUQsaUNBQTJCOzs7OztJQUMzQiwrQkFBMkI7Ozs7O0lBQzNCLHNDQUVvQzs7Ozs7SUFDcEMsZ0NBQWlDOzs7OztJQUNqQyxzQ0FBdUQ7Ozs7O0lBQ3ZELDRDQUFpRDs7Ozs7SUFDakQscUNBRTBCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgSW5qZWN0b3IsIE9wdGlvbmFsLCBTa2lwU2VsZiwgSW5qZWN0LCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gIGZvcmtKb2luLFxuICBmcm9tLFxuICBPYnNlcnZhYmxlLFxuICBvZixcbiAgdGhyb3dFcnJvcixcbiAgU3Vic2NyaXB0aW9uLFxuICBTdWJqZWN0LFxuICBpc09ic2VydmFibGVcbn0gZnJvbSAncnhqcyc7XG5pbXBvcnQge1xuICBjYXRjaEVycm9yLFxuICBkZWZhdWx0SWZFbXB0eSxcbiAgZmlsdGVyLFxuICBtYXAsXG4gIG1lcmdlTWFwLFxuICBzaGFyZVJlcGxheSxcbiAgdGFrZVVudGlsXG59IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IElOSVRJQUxfU1RBVEVfVE9LRU4sIFBsYWluT2JqZWN0T2YsIG1lbW9pemUgfSBmcm9tICdAbmd4cy9zdG9yZS9pbnRlcm5hbHMnO1xuXG5pbXBvcnQgeyBNRVRBX0tFWSwgTmd4c0NvbmZpZyB9IGZyb20gJy4uL3N5bWJvbHMnO1xuaW1wb3J0IHtcbiAgYnVpbGRHcmFwaCxcbiAgZmluZEZ1bGxQYXJlbnRQYXRoLFxuICBpc09iamVjdCxcbiAgTWFwcGVkU3RvcmUsXG4gIE1ldGFEYXRhTW9kZWwsXG4gIG5hbWVUb1N0YXRlLFxuICBwcm9wR2V0dGVyLFxuICBTdGF0ZUNsYXNzSW50ZXJuYWwsXG4gIFN0YXRlS2V5R3JhcGgsXG4gIFN0YXRlc0FuZERlZmF1bHRzLFxuICBTdGF0ZXNCeU5hbWUsXG4gIHRvcG9sb2dpY2FsU29ydCxcbiAgUnVudGltZVNlbGVjdG9yQ29udGV4dCxcbiAgU2hhcmVkU2VsZWN0b3JPcHRpb25zLFxuICBnZXRTdG9yZU1ldGFkYXRhXG59IGZyb20gJy4vaW50ZXJuYWxzJztcbmltcG9ydCB7IGdldEFjdGlvblR5cGVGcm9tSW5zdGFuY2UsIGdldFZhbHVlLCBzZXRWYWx1ZSB9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcbmltcG9ydCB7IG9mQWN0aW9uRGlzcGF0Y2hlZCB9IGZyb20gJy4uL29wZXJhdG9ycy9vZi1hY3Rpb24nO1xuaW1wb3J0IHsgQWN0aW9uQ29udGV4dCwgQWN0aW9uU3RhdHVzLCBJbnRlcm5hbEFjdGlvbnMgfSBmcm9tICcuLi9hY3Rpb25zLXN0cmVhbSc7XG5pbXBvcnQgeyBJbnRlcm5hbERpc3BhdGNoZWRBY3Rpb25SZXN1bHRzIH0gZnJvbSAnLi4vaW50ZXJuYWwvZGlzcGF0Y2hlcic7XG5pbXBvcnQgeyBTdGF0ZUNvbnRleHRGYWN0b3J5IH0gZnJvbSAnLi4vaW50ZXJuYWwvc3RhdGUtY29udGV4dC1mYWN0b3J5JztcbmltcG9ydCB7IFN0b3JlVmFsaWRhdG9ycyB9IGZyb20gJy4uL3V0aWxzL3N0b3JlLXZhbGlkYXRvcnMnO1xuaW1wb3J0IHsgZW5zdXJlU3RhdGVDbGFzc0lzSW5qZWN0YWJsZSB9IGZyb20gJy4uL2l2eS9pdnktZW5hYmxlZC1pbi1kZXYtbW9kZSc7XG5cbi8qKlxuICogU3RhdGUgZmFjdG9yeSBjbGFzc1xuICogQGlnbm9yZVxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgU3RhdGVGYWN0b3J5IGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBfYWN0aW9uc1N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uIHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfaW5qZWN0b3I6IEluamVjdG9yLFxuICAgIHByaXZhdGUgX2NvbmZpZzogTmd4c0NvbmZpZyxcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBTa2lwU2VsZigpXG4gICAgcHJpdmF0ZSBfcGFyZW50RmFjdG9yeTogU3RhdGVGYWN0b3J5LFxuICAgIHByaXZhdGUgX2FjdGlvbnM6IEludGVybmFsQWN0aW9ucyxcbiAgICBwcml2YXRlIF9hY3Rpb25SZXN1bHRzOiBJbnRlcm5hbERpc3BhdGNoZWRBY3Rpb25SZXN1bHRzLFxuICAgIHByaXZhdGUgX3N0YXRlQ29udGV4dEZhY3Rvcnk6IFN0YXRlQ29udGV4dEZhY3RvcnksXG4gICAgQE9wdGlvbmFsKClcbiAgICBASW5qZWN0KElOSVRJQUxfU1RBVEVfVE9LRU4pXG4gICAgcHJpdmF0ZSBfaW5pdGlhbFN0YXRlOiBhbnlcbiAgKSB7fVxuXG4gIHByaXZhdGUgX3N0YXRlczogTWFwcGVkU3RvcmVbXSA9IFtdO1xuXG4gIGdldCBzdGF0ZXMoKTogTWFwcGVkU3RvcmVbXSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudEZhY3RvcnkgPyB0aGlzLl9wYXJlbnRGYWN0b3J5LnN0YXRlcyA6IHRoaXMuX3N0YXRlcztcbiAgfVxuXG4gIHByaXZhdGUgX3N0YXRlc0J5TmFtZTogU3RhdGVzQnlOYW1lID0ge307XG5cbiAgZ2V0IHN0YXRlc0J5TmFtZSgpOiBTdGF0ZXNCeU5hbWUge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnRGYWN0b3J5ID8gdGhpcy5fcGFyZW50RmFjdG9yeS5zdGF0ZXNCeU5hbWUgOiB0aGlzLl9zdGF0ZXNCeU5hbWU7XG4gIH1cblxuICBwcml2YXRlIF9zdGF0ZVBhdGhzOiBQbGFpbk9iamVjdE9mPHN0cmluZz4gPSB7fTtcblxuICBwcml2YXRlIGdldCBzdGF0ZVBhdGhzKCk6IFBsYWluT2JqZWN0T2Y8c3RyaW5nPiB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudEZhY3RvcnkgPyB0aGlzLl9wYXJlbnRGYWN0b3J5LnN0YXRlUGF0aHMgOiB0aGlzLl9zdGF0ZVBhdGhzO1xuICB9XG5cbiAgZ2V0UnVudGltZVNlbGVjdG9yQ29udGV4dCA9IG1lbW9pemUoKCkgPT4ge1xuICAgIGNvbnN0IHN0YXRlRmFjdG9yeSA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlR2V0dGVyKGtleTogc3RyaW5nKSB7XG4gICAgICBjb25zdCBwYXRoID0gc3RhdGVGYWN0b3J5LnN0YXRlUGF0aHNba2V5XTtcbiAgICAgIHJldHVybiBwYXRoID8gcHJvcEdldHRlcihwYXRoLnNwbGl0KCcuJyksIHN0YXRlRmFjdG9yeS5fY29uZmlnKSA6IG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgY29udGV4dDogUnVudGltZVNlbGVjdG9yQ29udGV4dCA9IHRoaXMuX3BhcmVudEZhY3RvcnlcbiAgICAgID8gdGhpcy5fcGFyZW50RmFjdG9yeS5nZXRSdW50aW1lU2VsZWN0b3JDb250ZXh0KClcbiAgICAgIDoge1xuICAgICAgICAgIGdldFN0YXRlR2V0dGVyKGtleTogc3RyaW5nKSB7XG4gICAgICAgICAgICBsZXQgZ2V0dGVyID0gcmVzb2x2ZUdldHRlcihrZXkpO1xuICAgICAgICAgICAgaWYgKGdldHRlcikge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgIC8vIExhdGUgbG9hZGVkIGdldHRlclxuICAgICAgICAgICAgICBpZiAoIWdldHRlcikge1xuICAgICAgICAgICAgICAgIGdldHRlciA9IHJlc29sdmVHZXR0ZXIoa2V5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZ2V0dGVyID8gZ2V0dGVyKC4uLmFyZ3MpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldFNlbGVjdG9yT3B0aW9ucyhsb2NhbE9wdGlvbnM/OiBTaGFyZWRTZWxlY3Rvck9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGdsb2JhbFNlbGVjdG9yT3B0aW9ucyA9IHN0YXRlRmFjdG9yeS5fY29uZmlnLnNlbGVjdG9yT3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLmdsb2JhbFNlbGVjdG9yT3B0aW9ucyxcbiAgICAgICAgICAgICAgLi4uKGxvY2FsT3B0aW9ucyB8fCB7fSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9KTtcblxuICBwcml2YXRlIHN0YXRpYyBjbG9uZURlZmF1bHRzKGRlZmF1bHRzOiBhbnkpOiBhbnkge1xuICAgIGxldCB2YWx1ZSA9IHt9O1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmYXVsdHMpKSB7XG4gICAgICB2YWx1ZSA9IGRlZmF1bHRzLnNsaWNlKCk7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChkZWZhdWx0cykpIHtcbiAgICAgIHZhbHVlID0geyAuLi5kZWZhdWx0cyB9O1xuICAgIH0gZWxzZSBpZiAoZGVmYXVsdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsdWUgPSB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBkZWZhdWx0cztcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAvLyBJJ20gdXNpbmcgbm9uLW51bGwgYXNzZXJ0aW9uIGhlcmUgc2luY2UgYF9hY3Rpb25zU3Vic2NyaXRpb25gIHdpbGxcbiAgICAvLyBiZSAxMDAlIGRlZmluZWQuIFRoaXMgaXMgYmVjYXVzZSBgbmdPbkRlc3Ryb3koKWAgY2Fubm90IGJlIGludm9rZWRcbiAgICAvLyBvbiB0aGUgYFN0YXRlRmFjdG9yeWAgdW50aWwgaXRzIGluaXRpYWxpemVkIDopIEFuIGl0J3MgaW5pdGlhbGl6ZWRcbiAgICAvLyBmb3IgdGhlIGZpcnN0IHRpbWUgYWxvbmcgd2l0aCB0aGUgYE5neHNSb290TW9kdWxlYC5cbiAgICB0aGlzLl9hY3Rpb25zU3Vic2NyaXB0aW9uIS51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBzdGF0ZSB0byB0aGUgZ2xvYmFsIGRlZnMuXG4gICAqL1xuICBhZGQoc3RhdGVDbGFzc2VzOiBTdGF0ZUNsYXNzSW50ZXJuYWxbXSk6IE1hcHBlZFN0b3JlW10ge1xuICAgIC8vIENhcmV0YWtlciBub3RlOiB3ZSBoYXZlIHN0aWxsIGxlZnQgdGhlIGB0eXBlb2ZgIGNvbmRpdGlvbiBpbiBvcmRlciB0byBhdm9pZFxuICAgIC8vIGNyZWF0aW5nIGEgYnJlYWtpbmcgY2hhbmdlIGZvciBwcm9qZWN0cyB0aGF0IHN0aWxsIHVzZSB0aGUgVmlldyBFbmdpbmUuXG4gICAgaWYgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkge1xuICAgICAgU3RvcmVWYWxpZGF0b3JzLmNoZWNrVGhhdFN0YXRlQ2xhc3Nlc0hhdmVCZWVuRGVjb3JhdGVkKHN0YXRlQ2xhc3Nlcyk7XG4gICAgfVxuXG4gICAgY29uc3QgeyBuZXdTdGF0ZXMgfSA9IHRoaXMuYWRkVG9TdGF0ZXNNYXAoc3RhdGVDbGFzc2VzKTtcbiAgICBpZiAoIW5ld1N0YXRlcy5sZW5ndGgpIHJldHVybiBbXTtcblxuICAgIGNvbnN0IHN0YXRlR3JhcGg6IFN0YXRlS2V5R3JhcGggPSBidWlsZEdyYXBoKG5ld1N0YXRlcyk7XG4gICAgY29uc3Qgc29ydGVkU3RhdGVzOiBzdHJpbmdbXSA9IHRvcG9sb2dpY2FsU29ydChzdGF0ZUdyYXBoKTtcbiAgICBjb25zdCBwYXRoczogUGxhaW5PYmplY3RPZjxzdHJpbmc+ID0gZmluZEZ1bGxQYXJlbnRQYXRoKHN0YXRlR3JhcGgpO1xuICAgIGNvbnN0IG5hbWVHcmFwaDogUGxhaW5PYmplY3RPZjxTdGF0ZUNsYXNzSW50ZXJuYWw+ID0gbmFtZVRvU3RhdGUobmV3U3RhdGVzKTtcbiAgICBjb25zdCBib290c3RyYXBwZWRTdG9yZXM6IE1hcHBlZFN0b3JlW10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgbmFtZSBvZiBzb3J0ZWRTdGF0ZXMpIHtcbiAgICAgIGNvbnN0IHN0YXRlQ2xhc3M6IFN0YXRlQ2xhc3NJbnRlcm5hbCA9IG5hbWVHcmFwaFtuYW1lXTtcbiAgICAgIGNvbnN0IHBhdGg6IHN0cmluZyA9IHBhdGhzW25hbWVdO1xuICAgICAgY29uc3QgbWV0YTogTWV0YURhdGFNb2RlbCA9IHN0YXRlQ2xhc3NbTUVUQV9LRVldITtcblxuICAgICAgdGhpcy5hZGRSdW50aW1lSW5mb1RvTWV0YShtZXRhLCBwYXRoKTtcblxuICAgICAgLy8gTm90ZTogcHJldmlvdXNseSB3ZSBjYWxsZWQgYGVuc3VyZVN0YXRlQ2xhc3NJc0luamVjdGFibGVgIHdpdGhpbiB0aGVcbiAgICAgIC8vIGBTdGF0ZWAgZGVjb3JhdG9yLiBUaGlzIGNoZWNrIGlzIG1vdmVkIGhlcmUgYmVjYXVzZSB0aGUgYMm1cHJvdmAgcHJvcGVydHlcbiAgICAgIC8vIHdpbGwgbm90IGV4aXN0IG9uIHRoZSBjbGFzcyBpbiBKSVQgbW9kZSAoYmVjYXVzZSBpdCdzIHNldCBhc3luY2hyb25vdXNseVxuICAgICAgLy8gZHVyaW5nIEpJVCBjb21waWxhdGlvbiB0aHJvdWdoIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgKS5cbiAgICAgIGlmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpIHtcbiAgICAgICAgZW5zdXJlU3RhdGVDbGFzc0lzSW5qZWN0YWJsZShzdGF0ZUNsYXNzKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3RhdGVNYXA6IE1hcHBlZFN0b3JlID0ge1xuICAgICAgICBuYW1lLFxuICAgICAgICBwYXRoLFxuICAgICAgICBpc0luaXRpYWxpc2VkOiBmYWxzZSxcbiAgICAgICAgYWN0aW9uczogbWV0YS5hY3Rpb25zLFxuICAgICAgICBpbnN0YW5jZTogdGhpcy5faW5qZWN0b3IuZ2V0KHN0YXRlQ2xhc3MpLFxuICAgICAgICBkZWZhdWx0czogU3RhdGVGYWN0b3J5LmNsb25lRGVmYXVsdHMobWV0YS5kZWZhdWx0cylcbiAgICAgIH07XG5cbiAgICAgIC8vIGVuc3VyZSBvdXIgc3RvcmUgaGFzbid0IGFscmVhZHkgYmVlbiBhZGRlZFxuICAgICAgLy8gYnV0IGRvbid0IHRocm93IHNpbmNlIGl0IGNvdWxkIGJlIGxhenlcbiAgICAgIC8vIGxvYWRlZCBmcm9tIGRpZmZlcmVudCBwYXRoc1xuICAgICAgaWYgKCF0aGlzLmhhc0JlZW5Nb3VudGVkQW5kQm9vdHN0cmFwcGVkKG5hbWUsIHBhdGgpKSB7XG4gICAgICAgIGJvb3RzdHJhcHBlZFN0b3Jlcy5wdXNoKHN0YXRlTWFwKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGF0ZXMucHVzaChzdGF0ZU1hcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvb3RzdHJhcHBlZFN0b3JlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBzZXQgb2Ygc3RhdGVzIHRvIHRoZSBzdG9yZSBhbmQgcmV0dXJuIHRoZSBkZWZhdWx0c1xuICAgKi9cbiAgYWRkQW5kUmV0dXJuRGVmYXVsdHMoc3RhdGVDbGFzc2VzOiBTdGF0ZUNsYXNzSW50ZXJuYWxbXSk6IFN0YXRlc0FuZERlZmF1bHRzIHtcbiAgICBjb25zdCBjbGFzc2VzOiBTdGF0ZUNsYXNzSW50ZXJuYWxbXSA9IHN0YXRlQ2xhc3NlcyB8fCBbXTtcblxuICAgIGNvbnN0IG1hcHBlZFN0b3JlczogTWFwcGVkU3RvcmVbXSA9IHRoaXMuYWRkKGNsYXNzZXMpO1xuICAgIGNvbnN0IGRlZmF1bHRzID0gbWFwcGVkU3RvcmVzLnJlZHVjZShcbiAgICAgIChyZXN1bHQ6IGFueSwgbWFwcGVkU3RvcmU6IE1hcHBlZFN0b3JlKSA9PlxuICAgICAgICBzZXRWYWx1ZShyZXN1bHQsIG1hcHBlZFN0b3JlLnBhdGgsIG1hcHBlZFN0b3JlLmRlZmF1bHRzKSxcbiAgICAgIHt9XG4gICAgKTtcbiAgICByZXR1cm4geyBkZWZhdWx0cywgc3RhdGVzOiBtYXBwZWRTdG9yZXMgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kIHRoZSBhY3Rpb25zIHRvIHRoZSBoYW5kbGVyc1xuICAgKi9cbiAgY29ubmVjdEFjdGlvbkhhbmRsZXJzKCkge1xuICAgIGlmICh0aGlzLl9hY3Rpb25zU3Vic2NyaXB0aW9uICE9PSBudWxsKSByZXR1cm47XG4gICAgY29uc3QgZGlzcGF0Y2hlZCQgPSBuZXcgU3ViamVjdDxBY3Rpb25Db250ZXh0PigpO1xuICAgIHRoaXMuX2FjdGlvbnNTdWJzY3JpcHRpb24gPSB0aGlzLl9hY3Rpb25zXG4gICAgICAucGlwZShcbiAgICAgICAgZmlsdGVyKChjdHg6IEFjdGlvbkNvbnRleHQpID0+IGN0eC5zdGF0dXMgPT09IEFjdGlvblN0YXR1cy5EaXNwYXRjaGVkKSxcbiAgICAgICAgbWVyZ2VNYXAoY3R4ID0+IHtcbiAgICAgICAgICBkaXNwYXRjaGVkJC5uZXh0KGN0eCk7XG4gICAgICAgICAgY29uc3QgYWN0aW9uID0gY3R4LmFjdGlvbjtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pbnZva2VBY3Rpb25zKGRpc3BhdGNoZWQkLCBhY3Rpb24hKS5waXBlKFxuICAgICAgICAgICAgbWFwKCgpID0+IDxBY3Rpb25Db250ZXh0PnsgYWN0aW9uLCBzdGF0dXM6IEFjdGlvblN0YXR1cy5TdWNjZXNzZnVsIH0pLFxuICAgICAgICAgICAgZGVmYXVsdElmRW1wdHkoPEFjdGlvbkNvbnRleHQ+eyBhY3Rpb24sIHN0YXR1czogQWN0aW9uU3RhdHVzLkNhbmNlbGVkIH0pLFxuICAgICAgICAgICAgY2F0Y2hFcnJvcihlcnJvciA9PlxuICAgICAgICAgICAgICBvZig8QWN0aW9uQ29udGV4dD57IGFjdGlvbiwgc3RhdHVzOiBBY3Rpb25TdGF0dXMuRXJyb3JlZCwgZXJyb3IgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9KVxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZShjdHggPT4gdGhpcy5fYWN0aW9uUmVzdWx0cy5uZXh0KGN0eCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZSBhY3Rpb25zIG9uIHRoZSBzdGF0ZXMuXG4gICAqL1xuICBpbnZva2VBY3Rpb25zKGRpc3BhdGNoZWQkOiBPYnNlcnZhYmxlPEFjdGlvbkNvbnRleHQ+LCBhY3Rpb246IGFueSkge1xuICAgIGNvbnN0IHR5cGUgPSBnZXRBY3Rpb25UeXBlRnJvbUluc3RhbmNlKGFjdGlvbikhO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgIGZvciAoY29uc3QgbWV0YWRhdGEgb2YgdGhpcy5zdGF0ZXMpIHtcbiAgICAgIGNvbnN0IGFjdGlvbk1ldGFzID0gbWV0YWRhdGEuYWN0aW9uc1t0eXBlXTtcblxuICAgICAgaWYgKGFjdGlvbk1ldGFzKSB7XG4gICAgICAgIGZvciAoY29uc3QgYWN0aW9uTWV0YSBvZiBhY3Rpb25NZXRhcykge1xuICAgICAgICAgIGNvbnN0IHN0YXRlQ29udGV4dCA9IHRoaXMuX3N0YXRlQ29udGV4dEZhY3RvcnkuY3JlYXRlU3RhdGVDb250ZXh0KG1ldGFkYXRhKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG1ldGFkYXRhLmluc3RhbmNlW2FjdGlvbk1ldGEuZm5dKHN0YXRlQ29udGV4dCwgYWN0aW9uKTtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gZnJvbShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNPYnNlcnZhYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhpcyBvYnNlcnZhYmxlIGhhcyBiZWVuIGNvbXBsZXRlZCB3L28gZW1pdHRpbmdcbiAgICAgICAgICAgICAgLy8gYW55IHZhbHVlIHRoZW4gd2Ugd291bGRuJ3Qgd2FudCB0byBjb21wbGV0ZSB0aGUgd2hvbGUgY2hhaW5cbiAgICAgICAgICAgICAgLy8gb2YgYWN0aW9ucy4gU2luY2UgaWYgYW55IG9ic2VydmFibGUgY29tcGxldGVzIHRoZW5cbiAgICAgICAgICAgICAgLy8gYWN0aW9uIHdpbGwgYmUgY2FuY2VsZWQuXG4gICAgICAgICAgICAgIC8vIEZvciBpbnN0YW5jZSBpZiBhbnkgYWN0aW9uIGhhbmRsZXIgd291bGQndmUgaGFkIHN1Y2ggc3RhdGVtZW50OlxuICAgICAgICAgICAgICAvLyBgaGFuZGxlcihjdHgpIHsgcmV0dXJuIEVNUFRZOyB9YFxuICAgICAgICAgICAgICAvLyB0aGVuIHRoZSBhY3Rpb24gd2lsbCBiZSBjYW5jZWxlZC5cbiAgICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9uZ3hzL3N0b3JlL2lzc3Vlcy8xNTY4XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5waXBlKFxuICAgICAgICAgICAgICAgIG1lcmdlTWFwKCh2YWx1ZTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmcm9tKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChpc09ic2VydmFibGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiBvZih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgZGVmYXVsdElmRW1wdHkoe30pXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgaWYgKGFjdGlvbk1ldGEub3B0aW9ucy5jYW5jZWxVbmNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgIC8vIHRvZG86IG9mQWN0aW9uRGlzcGF0Y2hlZCBzaG91bGQgYmUgdXNlZCB3aXRoIGFjdGlvbiBjbGFzc1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5waXBlKFxuICAgICAgICAgICAgICAgICAgdGFrZVVudGlsKGRpc3BhdGNoZWQkLnBpcGUob2ZBY3Rpb25EaXNwYXRjaGVkKGFjdGlvbiBhcyBhbnkpKSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQgPSBvZih7fSkucGlwZShzaGFyZVJlcGxheSgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRocm93RXJyb3IoZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdHMucHVzaChvZih7fSkpO1xuICAgIH1cblxuICAgIHJldHVybiBmb3JrSm9pbihyZXN1bHRzKTtcbiAgfVxuXG4gIHByaXZhdGUgYWRkVG9TdGF0ZXNNYXAoXG4gICAgc3RhdGVDbGFzc2VzOiBTdGF0ZUNsYXNzSW50ZXJuYWxbXVxuICApOiB7IG5ld1N0YXRlczogU3RhdGVDbGFzc0ludGVybmFsW10gfSB7XG4gICAgY29uc3QgbmV3U3RhdGVzOiBTdGF0ZUNsYXNzSW50ZXJuYWxbXSA9IFtdO1xuICAgIGNvbnN0IHN0YXRlc01hcDogU3RhdGVzQnlOYW1lID0gdGhpcy5zdGF0ZXNCeU5hbWU7XG5cbiAgICBmb3IgKGNvbnN0IHN0YXRlQ2xhc3Mgb2Ygc3RhdGVDbGFzc2VzKSB7XG4gICAgICBjb25zdCBzdGF0ZU5hbWUgPSBnZXRTdG9yZU1ldGFkYXRhKHN0YXRlQ2xhc3MpLm5hbWUhO1xuICAgICAgLy8gQ2FyZXRha2VyIG5vdGU6IHdlIGhhdmUgc3RpbGwgbGVmdCB0aGUgYHR5cGVvZmAgY29uZGl0aW9uIGluIG9yZGVyIHRvIGF2b2lkXG4gICAgICAvLyBjcmVhdGluZyBhIGJyZWFraW5nIGNoYW5nZSBmb3IgcHJvamVjdHMgdGhhdCBzdGlsbCB1c2UgdGhlIFZpZXcgRW5naW5lLlxuICAgICAgaWYgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkge1xuICAgICAgICBTdG9yZVZhbGlkYXRvcnMuY2hlY2tUaGF0U3RhdGVOYW1lSXNVbmlxdWUoc3RhdGVOYW1lLCBzdGF0ZUNsYXNzLCBzdGF0ZXNNYXApO1xuICAgICAgfVxuICAgICAgY29uc3QgdW5tb3VudGVkU3RhdGUgPSAhc3RhdGVzTWFwW3N0YXRlTmFtZV07XG4gICAgICBpZiAodW5tb3VudGVkU3RhdGUpIHtcbiAgICAgICAgbmV3U3RhdGVzLnB1c2goc3RhdGVDbGFzcyk7XG4gICAgICAgIHN0YXRlc01hcFtzdGF0ZU5hbWVdID0gc3RhdGVDbGFzcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBuZXdTdGF0ZXMgfTtcbiAgfVxuXG4gIHByaXZhdGUgYWRkUnVudGltZUluZm9Ub01ldGEobWV0YTogTWV0YURhdGFNb2RlbCwgcGF0aDogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5zdGF0ZVBhdGhzW21ldGEubmFtZSFdID0gcGF0aDtcbiAgICAvLyBUT0RPOiB2NCAtIHdlIHBsYW4gdG8gZ2V0IHJpZCBvZiB0aGUgcGF0aCBwcm9wZXJ0eSBiZWNhdXNlIGl0IGlzIG5vbi1kZXRlcm1pbmlzdGljXG4gICAgLy8gd2UgY2FuIGRvIHRoaXMgd2hlbiB3ZSBnZXQgcmlkIG9mIHRoZSBpbmNvcnJlY3RseSBleHBvc2VkIGdldFN0b3JlTWV0YWRhdGFcbiAgICAvLyBXZSB3aWxsIG5lZWQgdG8gY29tZSB1cCB3aXRoIGFuIGFsdGVybmF0aXZlIGluIHY0IGJlY2F1c2UgdGhpcyBpcyB1c2VkIGJ5IG1hbnkgcGx1Z2luc1xuICAgIG1ldGEucGF0aCA9IHBhdGg7XG4gIH1cblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIHRoZSBtZXRob2QgY2hlY2tzIGlmIHRoZSBzdGF0ZSBoYXMgYWxyZWFkeSBiZWVuIGFkZGVkIHRvIHRoZSB0cmVlXG4gICAqIGFuZCBjb21wbGV0ZWQgdGhlIGxpZmUgY3ljbGVcbiAgICogQHBhcmFtIG5hbWVcbiAgICogQHBhcmFtIHBhdGhcbiAgICovXG4gIHByaXZhdGUgaGFzQmVlbk1vdW50ZWRBbmRCb290c3RyYXBwZWQobmFtZTogc3RyaW5nLCBwYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCB2YWx1ZUlzQm9vdHN0cmFwcGVkSW5Jbml0aWFsU3RhdGU6IGJvb2xlYW4gPVxuICAgICAgZ2V0VmFsdWUodGhpcy5faW5pdGlhbFN0YXRlLCBwYXRoKSAhPT0gdW5kZWZpbmVkO1xuICAgIHJldHVybiB0aGlzLnN0YXRlc0J5TmFtZVtuYW1lXSAmJiB2YWx1ZUlzQm9vdHN0cmFwcGVkSW5Jbml0aWFsU3RhdGU7XG4gIH1cbn1cbiJdfQ==