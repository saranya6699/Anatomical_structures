/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable, InjectionToken } from '@angular/core';
import { DispatchOutsideZoneNgxsExecutionStrategy } from './execution/dispatch-outside-zone-ngxs-execution-strategy';
/** @type {?} */
export const ROOT_STATE_TOKEN = new InjectionToken('ROOT_STATE_TOKEN');
/** @type {?} */
export const FEATURE_STATE_TOKEN = new InjectionToken('FEATURE_STATE_TOKEN');
/** @type {?} */
export const NGXS_PLUGINS = new InjectionToken('NGXS_PLUGINS');
/** @type {?} */
export const META_KEY = 'NGXS_META';
/** @type {?} */
export const META_OPTIONS_KEY = 'NGXS_OPTIONS_META';
/** @type {?} */
export const SELECTOR_META_KEY = 'NGXS_SELECTOR_META';
/**
 * The NGXS config settings.
 */
export class NgxsConfig {
    constructor() {
        /**
         * Defining the default state before module initialization
         * This is convenient if we need to create a define our own set of states.
         * @deprecated will be removed after v4
         * (default: {})
         */
        this.defaultsState = {};
        /**
         * Defining shared selector options
         */
        this.selectorOptions = {
            injectContainerState: true,
            // TODO: default is true in v3, will change in v4
            suppressErrors: true // TODO: default is true in v3, will change in v4
        };
        this.compatibility = {
            strictContentSecurityPolicy: false
        };
        this.executionStrategy = DispatchOutsideZoneNgxsExecutionStrategy;
    }
}
NgxsConfig.decorators = [
    { type: Injectable }
];
/** @nocollapse */
NgxsConfig.ctorParameters = () => [];
if (false) {
    /**
     * Run in development mode. This will add additional debugging features:
     * - Object.freeze on the state and actions to guarantee immutability
     * (default: false)
     *
     * Note: this property will be accounted only in development mode when using the Ivy compiler.
     * It makes sense to use it only during development to ensure there're no state mutations.
     * When building for production, the Object.freeze will be tree-shaken away.
     * @type {?}
     */
    NgxsConfig.prototype.developmentMode;
    /** @type {?} */
    NgxsConfig.prototype.compatibility;
    /**
     * Determines the execution context to perform async operations inside. An implementation can be
     * provided to override the default behaviour where the async operations are run
     * outside Angular's zone but all observable behaviours of NGXS are run back inside Angular's zone.
     * These observable behaviours are from:
     *   `\@Select(...)`, `store.select(...)`, `actions.subscribe(...)` or `store.dispatch(...).subscribe(...)`
     * Every `zone.run` causes Angular to run change detection on the whole tree (`app.tick()`) so of your
     * application doesn't rely on zone.js running change detection then you can switch to the
     * `NoopNgxsExecutionStrategy` that doesn't interact with zones.
     * (default: null)
     * @type {?}
     */
    NgxsConfig.prototype.executionStrategy;
    /**
     * Defining the default state before module initialization
     * This is convenient if we need to create a define our own set of states.
     * @deprecated will be removed after v4
     * (default: {})
     * @type {?}
     */
    NgxsConfig.prototype.defaultsState;
    /**
     * Defining shared selector options
     * @type {?}
     */
    NgxsConfig.prototype.selectorOptions;
}
/**
 * State context provided to the actions in the state.
 * @record
 * @template T
 */
export function StateContext() { }
if (false) {
    /**
     * Get the current state.
     * @return {?}
     */
    StateContext.prototype.getState = function () { };
    /**
     * Reset the state to a new value.
     * @param {?} val
     * @return {?}
     */
    StateContext.prototype.setState = function (val) { };
    /**
     * Patch the existing state with the provided value.
     * @param {?} val
     * @return {?}
     */
    StateContext.prototype.patchState = function (val) { };
    /**
     * Dispatch a new action and return the dispatched observable.
     * @param {?} actions
     * @return {?}
     */
    StateContext.prototype.dispatch = function (actions) { };
}
/**
 * Plugin interface
 * @record
 */
export function NgxsPlugin() { }
if (false) {
    /**
     * Handle the state/action before its submitted to the state handlers.
     * @param {?} state
     * @param {?} action
     * @param {?} next
     * @return {?}
     */
    NgxsPlugin.prototype.handle = function (state, action, next) { };
}
/**
 * Options that can be provided to the store.
 * @record
 * @template T
 */
export function StoreOptions() { }
if (false) {
    /**
     * Name of the state. Required.
     * @type {?}
     */
    StoreOptions.prototype.name;
    /**
     * Default values for the state. If not provided, uses empty object.
     * @type {?|undefined}
     */
    StoreOptions.prototype.defaults;
    /**
     * Sub states for the given state.
     * @type {?|undefined}
     */
    StoreOptions.prototype.children;
}
/**
 * Represents a basic change from a previous to a new value for a single state instance.
 * Passed as a value in a NgxsSimpleChanges object to the ngxsOnChanges hook.
 * @template T
 */
export class NgxsSimpleChange {
    /**
     * @param {?} previousValue
     * @param {?} currentValue
     * @param {?} firstChange
     */
    constructor(previousValue, currentValue, firstChange) {
        this.previousValue = previousValue;
        this.currentValue = currentValue;
        this.firstChange = firstChange;
    }
}
if (false) {
    /** @type {?} */
    NgxsSimpleChange.prototype.previousValue;
    /** @type {?} */
    NgxsSimpleChange.prototype.currentValue;
    /** @type {?} */
    NgxsSimpleChange.prototype.firstChange;
}
/**
 * On init interface
 * @record
 */
export function NgxsOnInit() { }
if (false) {
    /**
     * @param {?} ctx
     * @return {?}
     */
    NgxsOnInit.prototype.ngxsOnInit = function (ctx) { };
}
/**
 * On change interface
 * @record
 */
export function NgxsOnChanges() { }
if (false) {
    /**
     * @param {?} change
     * @return {?}
     */
    NgxsOnChanges.prototype.ngxsOnChanges = function (change) { };
}
/**
 * After bootstrap interface
 * @record
 */
export function NgxsAfterBootstrap() { }
if (false) {
    /**
     * @param {?} ctx
     * @return {?}
     */
    NgxsAfterBootstrap.prototype.ngxsAfterBootstrap = function (ctx) { };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3ltYm9scy5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuZ3hzL3N0b3JlLyIsInNvdXJjZXMiOlsic3JjL3N5bWJvbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsY0FBYyxFQUFRLE1BQU0sZUFBZSxDQUFDO0FBTWpFLE9BQU8sRUFBRSx3Q0FBd0MsRUFBRSxNQUFNLDJEQUEyRCxDQUFDOztBQUdySCxNQUFNLE9BQU8sZ0JBQWdCLEdBQUcsSUFBSSxjQUFjLENBQU0sa0JBQWtCLENBQUM7O0FBQzNFLE1BQU0sT0FBTyxtQkFBbUIsR0FBRyxJQUFJLGNBQWMsQ0FBTSxxQkFBcUIsQ0FBQzs7QUFDakYsTUFBTSxPQUFPLFlBQVksR0FBRyxJQUFJLGNBQWMsQ0FBQyxjQUFjLENBQUM7O0FBRTlELE1BQU0sT0FBTyxRQUFRLEdBQUcsV0FBVzs7QUFDbkMsTUFBTSxPQUFPLGdCQUFnQixHQUFHLG1CQUFtQjs7QUFDbkQsTUFBTSxPQUFPLGlCQUFpQixHQUFHLG9CQUFvQjs7OztBQVlyRCxNQUFNLE9BQU8sVUFBVTtJQThDckI7Ozs7Ozs7UUFUQSxrQkFBYSxHQUFnQixFQUFFLENBQUM7Ozs7UUFJaEMsb0JBQWUsR0FBMEI7WUFDdkMsb0JBQW9CLEVBQUUsSUFBSTs7WUFDMUIsY0FBYyxFQUFFLElBQUksQ0FBQyxpREFBaUQ7U0FDdkUsQ0FBQztRQUdBLElBQUksQ0FBQyxhQUFhLEdBQUc7WUFDbkIsMkJBQTJCLEVBQUUsS0FBSztTQUNuQyxDQUFDO1FBQ0YsSUFBSSxDQUFDLGlCQUFpQixHQUFHLHdDQUF3QyxDQUFDO0lBQ3BFLENBQUM7OztZQXBERixVQUFVOzs7Ozs7Ozs7Ozs7Ozs7SUFXVCxxQ0FBeUI7O0lBQ3pCLG1DQU9FOzs7Ozs7Ozs7Ozs7O0lBWUYsdUNBQStDOzs7Ozs7OztJQU8vQyxtQ0FBZ0M7Ozs7O0lBSWhDLHFDQUdFOzs7Ozs7O0FBZUosa0NBb0JDOzs7Ozs7SUFoQkMsa0RBQWM7Ozs7OztJQUtkLHFEQUF1Qzs7Ozs7O0lBS3ZDLHVEQUErQjs7Ozs7O0lBSy9CLHlEQUFpRDs7Ozs7O0FBUW5ELGdDQUtDOzs7Ozs7Ozs7SUFEQyxpRUFBNkQ7Ozs7Ozs7QUFNL0Qsa0NBZUM7Ozs7OztJQVhDLDRCQUE2Qjs7Ozs7SUFLN0IsZ0NBQWE7Ozs7O0lBS2IsZ0NBQXdCOzs7Ozs7O0FBTzFCLE1BQU0sT0FBTyxnQkFBZ0I7Ozs7OztJQUMzQixZQUNrQixhQUFnQixFQUNoQixZQUFlLEVBQ2YsV0FBb0I7UUFGcEIsa0JBQWEsR0FBYixhQUFhLENBQUc7UUFDaEIsaUJBQVksR0FBWixZQUFZLENBQUc7UUFDZixnQkFBVyxHQUFYLFdBQVcsQ0FBUztJQUNuQyxDQUFDO0NBQ0w7OztJQUpHLHlDQUFnQzs7SUFDaEMsd0NBQStCOztJQUMvQix1Q0FBb0M7Ozs7OztBQU94QyxnQ0FFQzs7Ozs7O0lBREMscURBQXlDOzs7Ozs7QUFNM0MsbUNBRUM7Ozs7OztJQURDLDhEQUE4Qzs7Ozs7O0FBTWhELHdDQUVDOzs7Ozs7SUFEQyxxRUFBaUQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3Rpb25Ub2tlbiwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBQbGFpbk9iamVjdCwgU3RhdGVDbGFzcyB9IGZyb20gJ0BuZ3hzL3N0b3JlL2ludGVybmFscyc7XG5pbXBvcnQgeyBTaGFyZWRTZWxlY3Rvck9wdGlvbnMgfSBmcm9tICcuL2ludGVybmFsL2ludGVybmFscyc7XG5pbXBvcnQgeyBOZ3hzRXhlY3V0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL2V4ZWN1dGlvbi9zeW1ib2xzJztcbmltcG9ydCB7IERpc3BhdGNoT3V0c2lkZVpvbmVOZ3hzRXhlY3V0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL2V4ZWN1dGlvbi9kaXNwYXRjaC1vdXRzaWRlLXpvbmUtbmd4cy1leGVjdXRpb24tc3RyYXRlZ3knO1xuaW1wb3J0IHsgU3RhdGVUb2tlbiB9IGZyb20gJy4vc3RhdGUtdG9rZW4vc3RhdGUtdG9rZW4nO1xuXG5leHBvcnQgY29uc3QgUk9PVF9TVEFURV9UT0tFTiA9IG5ldyBJbmplY3Rpb25Ub2tlbjxhbnk+KCdST09UX1NUQVRFX1RPS0VOJyk7XG5leHBvcnQgY29uc3QgRkVBVFVSRV9TVEFURV9UT0tFTiA9IG5ldyBJbmplY3Rpb25Ub2tlbjxhbnk+KCdGRUFUVVJFX1NUQVRFX1RPS0VOJyk7XG5leHBvcnQgY29uc3QgTkdYU19QTFVHSU5TID0gbmV3IEluamVjdGlvblRva2VuKCdOR1hTX1BMVUdJTlMnKTtcblxuZXhwb3J0IGNvbnN0IE1FVEFfS0VZID0gJ05HWFNfTUVUQSc7XG5leHBvcnQgY29uc3QgTUVUQV9PUFRJT05TX0tFWSA9ICdOR1hTX09QVElPTlNfTUVUQSc7XG5leHBvcnQgY29uc3QgU0VMRUNUT1JfTUVUQV9LRVkgPSAnTkdYU19TRUxFQ1RPUl9NRVRBJztcblxuZXhwb3J0IHR5cGUgTmd4c0xpZmVDeWNsZSA9IFBhcnRpYWw8Tmd4c09uQ2hhbmdlcz4gJlxuICBQYXJ0aWFsPE5neHNPbkluaXQ+ICZcbiAgUGFydGlhbDxOZ3hzQWZ0ZXJCb290c3RyYXA+O1xuXG5leHBvcnQgdHlwZSBOZ3hzUGx1Z2luRm4gPSAoc3RhdGU6IGFueSwgbXV0YXRpb246IGFueSwgbmV4dDogTmd4c05leHRQbHVnaW5GbikgPT4gYW55O1xuXG4vKipcbiAqIFRoZSBOR1hTIGNvbmZpZyBzZXR0aW5ncy5cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE5neHNDb25maWcge1xuICAvKipcbiAgICogUnVuIGluIGRldmVsb3BtZW50IG1vZGUuIFRoaXMgd2lsbCBhZGQgYWRkaXRpb25hbCBkZWJ1Z2dpbmcgZmVhdHVyZXM6XG4gICAqIC0gT2JqZWN0LmZyZWV6ZSBvbiB0aGUgc3RhdGUgYW5kIGFjdGlvbnMgdG8gZ3VhcmFudGVlIGltbXV0YWJpbGl0eVxuICAgKiAoZGVmYXVsdDogZmFsc2UpXG4gICAqXG4gICAqIE5vdGU6IHRoaXMgcHJvcGVydHkgd2lsbCBiZSBhY2NvdW50ZWQgb25seSBpbiBkZXZlbG9wbWVudCBtb2RlIHdoZW4gdXNpbmcgdGhlIEl2eSBjb21waWxlci5cbiAgICogSXQgbWFrZXMgc2Vuc2UgdG8gdXNlIGl0IG9ubHkgZHVyaW5nIGRldmVsb3BtZW50IHRvIGVuc3VyZSB0aGVyZSdyZSBubyBzdGF0ZSBtdXRhdGlvbnMuXG4gICAqIFdoZW4gYnVpbGRpbmcgZm9yIHByb2R1Y3Rpb24sIHRoZSBPYmplY3QuZnJlZXplIHdpbGwgYmUgdHJlZS1zaGFrZW4gYXdheS5cbiAgICovXG4gIGRldmVsb3BtZW50TW9kZTogYm9vbGVhbjtcbiAgY29tcGF0aWJpbGl0eToge1xuICAgIC8qKlxuICAgICAqIFN1cHBvcnQgYSBzdHJpY3QgQ29udGVudCBTZWN1cml0eSBQb2xpY3kuXG4gICAgICogVGhpcyB3aWxsIGNpcmN1bXZlbnQgc29tZSBvcHRpbWlzYXRpb25zIHRoYXQgdmlvbGF0ZSBhIHN0cmljdCBDU1AgdGhyb3VnaCB0aGUgdXNlIG9mIGBuZXcgRnVuY3Rpb24oLi4uKWAuXG4gICAgICogKGRlZmF1bHQ6IGZhbHNlKVxuICAgICAqL1xuICAgIHN0cmljdENvbnRlbnRTZWN1cml0eVBvbGljeTogYm9vbGVhbjtcbiAgfTtcbiAgLyoqXG4gICAqIERldGVybWluZXMgdGhlIGV4ZWN1dGlvbiBjb250ZXh0IHRvIHBlcmZvcm0gYXN5bmMgb3BlcmF0aW9ucyBpbnNpZGUuIEFuIGltcGxlbWVudGF0aW9uIGNhbiBiZVxuICAgKiBwcm92aWRlZCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgd2hlcmUgdGhlIGFzeW5jIG9wZXJhdGlvbnMgYXJlIHJ1blxuICAgKiBvdXRzaWRlIEFuZ3VsYXIncyB6b25lIGJ1dCBhbGwgb2JzZXJ2YWJsZSBiZWhhdmlvdXJzIG9mIE5HWFMgYXJlIHJ1biBiYWNrIGluc2lkZSBBbmd1bGFyJ3Mgem9uZS5cbiAgICogVGhlc2Ugb2JzZXJ2YWJsZSBiZWhhdmlvdXJzIGFyZSBmcm9tOlxuICAgKiAgIGBAU2VsZWN0KC4uLilgLCBgc3RvcmUuc2VsZWN0KC4uLilgLCBgYWN0aW9ucy5zdWJzY3JpYmUoLi4uKWAgb3IgYHN0b3JlLmRpc3BhdGNoKC4uLikuc3Vic2NyaWJlKC4uLilgXG4gICAqIEV2ZXJ5IGB6b25lLnJ1bmAgY2F1c2VzIEFuZ3VsYXIgdG8gcnVuIGNoYW5nZSBkZXRlY3Rpb24gb24gdGhlIHdob2xlIHRyZWUgKGBhcHAudGljaygpYCkgc28gb2YgeW91clxuICAgKiBhcHBsaWNhdGlvbiBkb2Vzbid0IHJlbHkgb24gem9uZS5qcyBydW5uaW5nIGNoYW5nZSBkZXRlY3Rpb24gdGhlbiB5b3UgY2FuIHN3aXRjaCB0byB0aGVcbiAgICogYE5vb3BOZ3hzRXhlY3V0aW9uU3RyYXRlZ3lgIHRoYXQgZG9lc24ndCBpbnRlcmFjdCB3aXRoIHpvbmVzLlxuICAgKiAoZGVmYXVsdDogbnVsbClcbiAgICovXG4gIGV4ZWN1dGlvblN0cmF0ZWd5OiBUeXBlPE5neHNFeGVjdXRpb25TdHJhdGVneT47XG4gIC8qKlxuICAgKiBEZWZpbmluZyB0aGUgZGVmYXVsdCBzdGF0ZSBiZWZvcmUgbW9kdWxlIGluaXRpYWxpemF0aW9uXG4gICAqIFRoaXMgaXMgY29udmVuaWVudCBpZiB3ZSBuZWVkIHRvIGNyZWF0ZSBhIGRlZmluZSBvdXIgb3duIHNldCBvZiBzdGF0ZXMuXG4gICAqIEBkZXByZWNhdGVkIHdpbGwgYmUgcmVtb3ZlZCBhZnRlciB2NFxuICAgKiAoZGVmYXVsdDoge30pXG4gICAqL1xuICBkZWZhdWx0c1N0YXRlOiBQbGFpbk9iamVjdCA9IHt9O1xuICAvKipcbiAgICogRGVmaW5pbmcgc2hhcmVkIHNlbGVjdG9yIG9wdGlvbnNcbiAgICovXG4gIHNlbGVjdG9yT3B0aW9uczogU2hhcmVkU2VsZWN0b3JPcHRpb25zID0ge1xuICAgIGluamVjdENvbnRhaW5lclN0YXRlOiB0cnVlLCAvLyBUT0RPOiBkZWZhdWx0IGlzIHRydWUgaW4gdjMsIHdpbGwgY2hhbmdlIGluIHY0XG4gICAgc3VwcHJlc3NFcnJvcnM6IHRydWUgLy8gVE9ETzogZGVmYXVsdCBpcyB0cnVlIGluIHYzLCB3aWxsIGNoYW5nZSBpbiB2NFxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY29tcGF0aWJpbGl0eSA9IHtcbiAgICAgIHN0cmljdENvbnRlbnRTZWN1cml0eVBvbGljeTogZmFsc2VcbiAgICB9O1xuICAgIHRoaXMuZXhlY3V0aW9uU3RyYXRlZ3kgPSBEaXNwYXRjaE91dHNpZGVab25lTmd4c0V4ZWN1dGlvblN0cmF0ZWd5O1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIFN0YXRlT3BlcmF0b3I8VD4gPSAoZXhpc3Rpbmc6IFJlYWRvbmx5PFQ+KSA9PiBUO1xuXG4vKipcbiAqIFN0YXRlIGNvbnRleHQgcHJvdmlkZWQgdG8gdGhlIGFjdGlvbnMgaW4gdGhlIHN0YXRlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRlQ29udGV4dDxUPiB7XG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAqL1xuICBnZXRTdGF0ZSgpOiBUO1xuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgc3RhdGUgdG8gYSBuZXcgdmFsdWUuXG4gICAqL1xuICBzZXRTdGF0ZSh2YWw6IFQgfCBTdGF0ZU9wZXJhdG9yPFQ+KTogVDtcblxuICAvKipcbiAgICogUGF0Y2ggdGhlIGV4aXN0aW5nIHN0YXRlIHdpdGggdGhlIHByb3ZpZGVkIHZhbHVlLlxuICAgKi9cbiAgcGF0Y2hTdGF0ZSh2YWw6IFBhcnRpYWw8VD4pOiBUO1xuXG4gIC8qKlxuICAgKiBEaXNwYXRjaCBhIG5ldyBhY3Rpb24gYW5kIHJldHVybiB0aGUgZGlzcGF0Y2hlZCBvYnNlcnZhYmxlLlxuICAgKi9cbiAgZGlzcGF0Y2goYWN0aW9uczogYW55IHwgYW55W10pOiBPYnNlcnZhYmxlPHZvaWQ+O1xufVxuXG5leHBvcnQgdHlwZSBOZ3hzTmV4dFBsdWdpbkZuID0gKHN0YXRlOiBhbnksIG11dGF0aW9uOiBhbnkpID0+IGFueTtcblxuLyoqXG4gKiBQbHVnaW4gaW50ZXJmYWNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmd4c1BsdWdpbiB7XG4gIC8qKlxuICAgKiBIYW5kbGUgdGhlIHN0YXRlL2FjdGlvbiBiZWZvcmUgaXRzIHN1Ym1pdHRlZCB0byB0aGUgc3RhdGUgaGFuZGxlcnMuXG4gICAqL1xuICBoYW5kbGUoc3RhdGU6IGFueSwgYWN0aW9uOiBhbnksIG5leHQ6IE5neHNOZXh0UGx1Z2luRm4pOiBhbnk7XG59XG5cbi8qKlxuICogT3B0aW9ucyB0aGF0IGNhbiBiZSBwcm92aWRlZCB0byB0aGUgc3RvcmUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3RvcmVPcHRpb25zPFQ+IHtcbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIHN0YXRlLiBSZXF1aXJlZC5cbiAgICovXG4gIG5hbWU6IHN0cmluZyB8IFN0YXRlVG9rZW48VD47XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgdmFsdWVzIGZvciB0aGUgc3RhdGUuIElmIG5vdCBwcm92aWRlZCwgdXNlcyBlbXB0eSBvYmplY3QuXG4gICAqL1xuICBkZWZhdWx0cz86IFQ7XG5cbiAgLyoqXG4gICAqIFN1YiBzdGF0ZXMgZm9yIHRoZSBnaXZlbiBzdGF0ZS5cbiAgICovXG4gIGNoaWxkcmVuPzogU3RhdGVDbGFzc1tdO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBiYXNpYyBjaGFuZ2UgZnJvbSBhIHByZXZpb3VzIHRvIGEgbmV3IHZhbHVlIGZvciBhIHNpbmdsZSBzdGF0ZSBpbnN0YW5jZS5cbiAqIFBhc3NlZCBhcyBhIHZhbHVlIGluIGEgTmd4c1NpbXBsZUNoYW5nZXMgb2JqZWN0IHRvIHRoZSBuZ3hzT25DaGFuZ2VzIGhvb2suXG4gKi9cbmV4cG9ydCBjbGFzcyBOZ3hzU2ltcGxlQ2hhbmdlPFQgPSBhbnk+IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHJlYWRvbmx5IHByZXZpb3VzVmFsdWU6IFQsXG4gICAgcHVibGljIHJlYWRvbmx5IGN1cnJlbnRWYWx1ZTogVCxcbiAgICBwdWJsaWMgcmVhZG9ubHkgZmlyc3RDaGFuZ2U6IGJvb2xlYW5cbiAgKSB7fVxufVxuXG4vKipcbiAqIE9uIGluaXQgaW50ZXJmYWNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmd4c09uSW5pdCB7XG4gIG5neHNPbkluaXQoY3R4OiBTdGF0ZUNvbnRleHQ8YW55Pik6IHZvaWQ7XG59XG5cbi8qKlxuICogT24gY2hhbmdlIGludGVyZmFjZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5neHNPbkNoYW5nZXMge1xuICBuZ3hzT25DaGFuZ2VzKGNoYW5nZTogTmd4c1NpbXBsZUNoYW5nZSk6IHZvaWQ7XG59XG5cbi8qKlxuICogQWZ0ZXIgYm9vdHN0cmFwIGludGVyZmFjZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5neHNBZnRlckJvb3RzdHJhcCB7XG4gIG5neHNBZnRlckJvb3RzdHJhcChjdHg6IFN0YXRlQ29udGV4dDxhbnk+KTogdm9pZDtcbn1cblxuZXhwb3J0IHR5cGUgTmd4c01vZHVsZU9wdGlvbnMgPSBQYXJ0aWFsPE5neHNDb25maWc+O1xuXG4vKiogQGludGVybmFsICovXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGNvbnN0IG5nRGV2TW9kZTogYm9vbGVhbjtcbn1cbiJdfQ==