/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { Subject, Observable } from 'rxjs';
import { share } from 'rxjs/operators';
import { leaveNgxs } from './operators/leave-ngxs';
import { InternalNgxsExecutionStrategy } from './execution/internal-ngxs-execution-strategy';
/** @enum {string} */
var ActionStatus = {
    Dispatched: 'DISPATCHED',
    Successful: 'SUCCESSFUL',
    Canceled: 'CANCELED',
    Errored: 'ERRORED',
};
export { ActionStatus };
/**
 * @record
 * @template T
 */
export function ActionContext() { }
if (false) {
    /** @type {?} */
    ActionContext.prototype.status;
    /** @type {?} */
    ActionContext.prototype.action;
    /** @type {?|undefined} */
    ActionContext.prototype.error;
}
/**
 * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.
 * A standard Subject does not have this guarantee.
 * For example, given the following code:
 * ```typescript
 *   const subject = new Subject<string>();
 * subject.subscribe(value => {
 * if (value === 'start') subject.next('end');
 * });
 * subject.subscribe(value => { });
 * subject.next('start');
 * ```
 * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.
 * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.
 * @template T
 */
var /**
 * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.
 * A standard Subject does not have this guarantee.
 * For example, given the following code:
 * ```typescript
 *   const subject = new Subject<string>();
 * subject.subscribe(value => {
 * if (value === 'start') subject.next('end');
 * });
 * subject.subscribe(value => { });
 * subject.next('start');
 * ```
 * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.
 * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.
 * @template T
 */
OrderedSubject = /** @class */ (function (_super) {
    tslib_1.__extends(OrderedSubject, _super);
    function OrderedSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._itemQueue = [];
        _this._busyPushingNext = false;
        return _this;
    }
    /**
     * @param {?=} value
     * @return {?}
     */
    OrderedSubject.prototype.next = /**
     * @param {?=} value
     * @return {?}
     */
    function (value) {
        if (this._busyPushingNext) {
            this._itemQueue.unshift((/** @type {?} */ (value)));
            return;
        }
        this._busyPushingNext = true;
        _super.prototype.next.call(this, value);
        while (this._itemQueue.length > 0) {
            /** @type {?} */
            var nextValue = this._itemQueue.pop();
            _super.prototype.next.call(this, nextValue);
        }
        this._busyPushingNext = false;
    };
    return OrderedSubject;
}(Subject));
/**
 * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.
 * A standard Subject does not have this guarantee.
 * For example, given the following code:
 * ```typescript
 *   const subject = new Subject<string>();
 * subject.subscribe(value => {
 * if (value === 'start') subject.next('end');
 * });
 * subject.subscribe(value => { });
 * subject.next('start');
 * ```
 * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.
 * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.
 * @template T
 */
export { OrderedSubject };
if (false) {
    /**
     * @type {?}
     * @private
     */
    OrderedSubject.prototype._itemQueue;
    /**
     * @type {?}
     * @private
     */
    OrderedSubject.prototype._busyPushingNext;
}
/**
 * Internal Action stream that is emitted anytime an action is dispatched.
 */
var InternalActions = /** @class */ (function (_super) {
    tslib_1.__extends(InternalActions, _super);
    function InternalActions() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @return {?}
     */
    InternalActions.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.complete();
    };
    InternalActions.decorators = [
        { type: Injectable }
    ];
    return InternalActions;
}(OrderedSubject));
export { InternalActions };
/**
 * Action stream that is emitted anytime an action is dispatched.
 *
 * You can listen to this in services to react without stores.
 */
var Actions = /** @class */ (function (_super) {
    tslib_1.__extends(Actions, _super);
    // This has to be `Observable<ActionContext>` in the v4. Because `InternalActions`
    // is a `Subject<ActionContext>`. Leave it as `any` to avoid breaking changes
    function Actions(internalActions$, internalExecutionStrategy) {
        var _this = this;
        /** @type {?} */
        var sharedInternalActions$ = internalActions$.pipe(leaveNgxs(internalExecutionStrategy), 
        // The `InternalActions` subject emits outside of the Angular zone.
        // We have to re-enter the Angular zone for any incoming consumer.
        // The `share()` operator reduces the number of change detections.
        // This would call leave only once for any stream emission across all active subscribers.
        share());
        _this = _super.call(this, (/**
         * @param {?} observer
         * @return {?}
         */
        function (observer) {
            /** @type {?} */
            var childSubscription = sharedInternalActions$.subscribe({
                next: (/**
                 * @param {?} ctx
                 * @return {?}
                 */
                function (ctx) { return observer.next(ctx); }),
                error: (/**
                 * @param {?} error
                 * @return {?}
                 */
                function (error) { return observer.error(error); }),
                complete: (/**
                 * @return {?}
                 */
                function () { return observer.complete(); })
            });
            observer.add(childSubscription);
        })) || this;
        return _this;
    }
    Actions.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    Actions.ctorParameters = function () { return [
        { type: InternalActions },
        { type: InternalNgxsExecutionStrategy }
    ]; };
    return Actions;
}(Observable));
export { Actions };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWN0aW9ucy1zdHJlYW0uanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Abmd4cy9zdG9yZS8iLCJzb3VyY2VzIjpbInNyYy9hY3Rpb25zLXN0cmVhbS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQWEsTUFBTSxlQUFlLENBQUM7QUFDdEQsT0FBTyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDM0MsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRXZDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUNuRCxPQUFPLEVBQUUsNkJBQTZCLEVBQUUsTUFBTSw4Q0FBOEMsQ0FBQzs7O0lBTTNGLFlBQWEsWUFBWTtJQUN6QixZQUFhLFlBQVk7SUFDekIsVUFBVyxVQUFVO0lBQ3JCLFNBQVUsU0FBUzs7Ozs7OztBQUdyQixtQ0FJQzs7O0lBSEMsK0JBQXFCOztJQUNyQiwrQkFBVTs7SUFDViw4QkFBYzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JoQjs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFBdUMsMENBQVU7SUFBakQ7UUFBQSxxRUFpQkM7UUFoQlMsZ0JBQVUsR0FBUSxFQUFFLENBQUM7UUFDckIsc0JBQWdCLEdBQUcsS0FBSyxDQUFDOztJQWVuQyxDQUFDOzs7OztJQWJDLDZCQUFJOzs7O0lBQUosVUFBSyxLQUFTO1FBQ1osSUFBSSxJQUFJLENBQUMsZ0JBQWdCLEVBQUU7WUFDekIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsbUJBQUEsS0FBSyxFQUFDLENBQUMsQ0FBQztZQUNoQyxPQUFPO1NBQ1I7UUFDRCxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDO1FBQzdCLGlCQUFNLElBQUksWUFBQyxLQUFLLENBQUMsQ0FBQztRQUNsQixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTs7Z0JBQzNCLFNBQVMsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsRUFBRTtZQUN2QyxpQkFBTSxJQUFJLFlBQUMsU0FBUyxDQUFDLENBQUM7U0FDdkI7UUFDRCxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsS0FBSyxDQUFDO0lBQ2hDLENBQUM7SUFDSCxxQkFBQztBQUFELENBQUMsQUFqQkQsQ0FBdUMsT0FBTyxHQWlCN0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBaEJDLG9DQUE2Qjs7Ozs7SUFDN0IsMENBQWlDOzs7OztBQW9CbkM7SUFDcUMsMkNBQTZCO0lBRGxFOztJQUtBLENBQUM7Ozs7SUFIQyxxQ0FBVzs7O0lBQVg7UUFDRSxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDbEIsQ0FBQzs7Z0JBSkYsVUFBVTs7SUFLWCxzQkFBQztDQUFBLEFBTEQsQ0FDcUMsY0FBYyxHQUlsRDtTQUpZLGVBQWU7Ozs7OztBQVc1QjtJQUM2QixtQ0FBZTtJQUMxQyxrRkFBa0Y7SUFDbEYsNkVBQTZFO0lBQzdFLGlCQUNFLGdCQUFpQyxFQUNqQyx5QkFBd0Q7UUFGMUQsaUJBc0JDOztZQWxCTyxzQkFBc0IsR0FBRyxnQkFBZ0IsQ0FBQyxJQUFJLENBQ2xELFNBQVMsQ0FBQyx5QkFBeUIsQ0FBQztRQUNwQyxtRUFBbUU7UUFDbkUsa0VBQWtFO1FBQ2xFLGtFQUFrRTtRQUNsRSx5RkFBeUY7UUFDekYsS0FBSyxFQUFFLENBQ1I7UUFFRCxRQUFBOzs7O1FBQU0sVUFBQSxRQUFROztnQkFDTixpQkFBaUIsR0FBRyxzQkFBc0IsQ0FBQyxTQUFTLENBQUM7Z0JBQ3pELElBQUk7Ozs7Z0JBQUUsVUFBQSxHQUFHLElBQUksT0FBQSxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFsQixDQUFrQixDQUFBO2dCQUMvQixLQUFLOzs7O2dCQUFFLFVBQUEsS0FBSyxJQUFJLE9BQUEsUUFBUSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBckIsQ0FBcUIsQ0FBQTtnQkFDckMsUUFBUTs7O2dCQUFFLGNBQU0sT0FBQSxRQUFRLENBQUMsUUFBUSxFQUFFLEVBQW5CLENBQW1CLENBQUE7YUFDcEMsQ0FBQztZQUVGLFFBQVEsQ0FBQyxHQUFHLENBQUMsaUJBQWlCLENBQUMsQ0FBQztRQUNsQyxDQUFDLEVBQUMsU0FBQzs7SUFDTCxDQUFDOztnQkExQkYsVUFBVTs7OztnQkFLVyxlQUFlO2dCQXhFNUIsNkJBQTZCOztJQThGdEMsY0FBQztDQUFBLEFBM0JELENBQzZCLFVBQVUsR0EwQnRDO1NBMUJZLE9BQU8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QsIE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHNoYXJlIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBsZWF2ZU5neHMgfSBmcm9tICcuL29wZXJhdG9ycy9sZWF2ZS1uZ3hzJztcbmltcG9ydCB7IEludGVybmFsTmd4c0V4ZWN1dGlvblN0cmF0ZWd5IH0gZnJvbSAnLi9leGVjdXRpb24vaW50ZXJuYWwtbmd4cy1leGVjdXRpb24tc3RyYXRlZ3knO1xuXG4vKipcbiAqIFN0YXR1cyBvZiBhIGRpc3BhdGNoZWQgYWN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBlbnVtIEFjdGlvblN0YXR1cyB7XG4gIERpc3BhdGNoZWQgPSAnRElTUEFUQ0hFRCcsXG4gIFN1Y2Nlc3NmdWwgPSAnU1VDQ0VTU0ZVTCcsXG4gIENhbmNlbGVkID0gJ0NBTkNFTEVEJyxcbiAgRXJyb3JlZCA9ICdFUlJPUkVEJ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFjdGlvbkNvbnRleHQ8VCA9IGFueT4ge1xuICBzdGF0dXM6IEFjdGlvblN0YXR1cztcbiAgYWN0aW9uOiBUO1xuICBlcnJvcj86IEVycm9yO1xufVxuXG4vKipcbiAqIEN1c3RvbSBTdWJqZWN0IHRoYXQgZW5zdXJlcyB0aGF0IHN1YnNjcmliZXJzIGFyZSBub3RpZmllZCBvZiB2YWx1ZXMgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBhcnJpdmVkLlxuICogQSBzdGFuZGFyZCBTdWJqZWN0IGRvZXMgbm90IGhhdmUgdGhpcyBndWFyYW50ZWUuXG4gKiBGb3IgZXhhbXBsZSwgZ2l2ZW4gdGhlIGZvbGxvd2luZyBjb2RlOlxuICogYGBgdHlwZXNjcmlwdFxuICogICBjb25zdCBzdWJqZWN0ID0gbmV3IFN1YmplY3Q8c3RyaW5nPigpO1xuICAgICBzdWJqZWN0LnN1YnNjcmliZSh2YWx1ZSA9PiB7XG4gICAgICAgaWYgKHZhbHVlID09PSAnc3RhcnQnKSBzdWJqZWN0Lm5leHQoJ2VuZCcpO1xuICAgICB9KTtcbiAgICAgc3ViamVjdC5zdWJzY3JpYmUodmFsdWUgPT4geyB9KTtcbiAgICAgc3ViamVjdC5uZXh0KCdzdGFydCcpO1xuICogYGBgXG4gKiBXaGVuIGBzdWJqZWN0YCBpcyBhIHN0YW5kYXJkIGBTdWJqZWN0PFQ+YCB0aGUgc2Vjb25kIHN1YnNjcmliZXIgd291bGQgcmVjaWV2ZSBgZW5kYCBhbmQgdGhlbiBgc3RhcnRgLlxuICogV2hlbiBgc3ViamVjdGAgaXMgYSBgT3JkZXJlZFN1YmplY3Q8VD5gIHRoZSBzZWNvbmQgc3Vic2NyaWJlciB3b3VsZCByZWNpZXZlIGBzdGFydGAgYW5kIHRoZW4gYGVuZGAuXG4gKi9cbmV4cG9ydCBjbGFzcyBPcmRlcmVkU3ViamVjdDxUPiBleHRlbmRzIFN1YmplY3Q8VD4ge1xuICBwcml2YXRlIF9pdGVtUXVldWU6IFRbXSA9IFtdO1xuICBwcml2YXRlIF9idXN5UHVzaGluZ05leHQgPSBmYWxzZTtcblxuICBuZXh0KHZhbHVlPzogVCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9idXN5UHVzaGluZ05leHQpIHtcbiAgICAgIHRoaXMuX2l0ZW1RdWV1ZS51bnNoaWZ0KHZhbHVlISk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2J1c3lQdXNoaW5nTmV4dCA9IHRydWU7XG4gICAgc3VwZXIubmV4dCh2YWx1ZSk7XG4gICAgd2hpbGUgKHRoaXMuX2l0ZW1RdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBuZXh0VmFsdWUgPSB0aGlzLl9pdGVtUXVldWUucG9wKCk7XG4gICAgICBzdXBlci5uZXh0KG5leHRWYWx1ZSk7XG4gICAgfVxuICAgIHRoaXMuX2J1c3lQdXNoaW5nTmV4dCA9IGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogSW50ZXJuYWwgQWN0aW9uIHN0cmVhbSB0aGF0IGlzIGVtaXR0ZWQgYW55dGltZSBhbiBhY3Rpb24gaXMgZGlzcGF0Y2hlZC5cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEludGVybmFsQWN0aW9ucyBleHRlbmRzIE9yZGVyZWRTdWJqZWN0PEFjdGlvbkNvbnRleHQ+IGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5jb21wbGV0ZSgpO1xuICB9XG59XG5cbi8qKlxuICogQWN0aW9uIHN0cmVhbSB0aGF0IGlzIGVtaXR0ZWQgYW55dGltZSBhbiBhY3Rpb24gaXMgZGlzcGF0Y2hlZC5cbiAqXG4gKiBZb3UgY2FuIGxpc3RlbiB0byB0aGlzIGluIHNlcnZpY2VzIHRvIHJlYWN0IHdpdGhvdXQgc3RvcmVzLlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQWN0aW9ucyBleHRlbmRzIE9ic2VydmFibGU8YW55PiB7XG4gIC8vIFRoaXMgaGFzIHRvIGJlIGBPYnNlcnZhYmxlPEFjdGlvbkNvbnRleHQ+YCBpbiB0aGUgdjQuIEJlY2F1c2UgYEludGVybmFsQWN0aW9uc2BcbiAgLy8gaXMgYSBgU3ViamVjdDxBY3Rpb25Db250ZXh0PmAuIExlYXZlIGl0IGFzIGBhbnlgIHRvIGF2b2lkIGJyZWFraW5nIGNoYW5nZXNcbiAgY29uc3RydWN0b3IoXG4gICAgaW50ZXJuYWxBY3Rpb25zJDogSW50ZXJuYWxBY3Rpb25zLFxuICAgIGludGVybmFsRXhlY3V0aW9uU3RyYXRlZ3k6IEludGVybmFsTmd4c0V4ZWN1dGlvblN0cmF0ZWd5XG4gICkge1xuICAgIGNvbnN0IHNoYXJlZEludGVybmFsQWN0aW9ucyQgPSBpbnRlcm5hbEFjdGlvbnMkLnBpcGUoXG4gICAgICBsZWF2ZU5neHMoaW50ZXJuYWxFeGVjdXRpb25TdHJhdGVneSksXG4gICAgICAvLyBUaGUgYEludGVybmFsQWN0aW9uc2Agc3ViamVjdCBlbWl0cyBvdXRzaWRlIG9mIHRoZSBBbmd1bGFyIHpvbmUuXG4gICAgICAvLyBXZSBoYXZlIHRvIHJlLWVudGVyIHRoZSBBbmd1bGFyIHpvbmUgZm9yIGFueSBpbmNvbWluZyBjb25zdW1lci5cbiAgICAgIC8vIFRoZSBgc2hhcmUoKWAgb3BlcmF0b3IgcmVkdWNlcyB0aGUgbnVtYmVyIG9mIGNoYW5nZSBkZXRlY3Rpb25zLlxuICAgICAgLy8gVGhpcyB3b3VsZCBjYWxsIGxlYXZlIG9ubHkgb25jZSBmb3IgYW55IHN0cmVhbSBlbWlzc2lvbiBhY3Jvc3MgYWxsIGFjdGl2ZSBzdWJzY3JpYmVycy5cbiAgICAgIHNoYXJlKClcbiAgICApO1xuXG4gICAgc3VwZXIob2JzZXJ2ZXIgPT4ge1xuICAgICAgY29uc3QgY2hpbGRTdWJzY3JpcHRpb24gPSBzaGFyZWRJbnRlcm5hbEFjdGlvbnMkLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6IGN0eCA9PiBvYnNlcnZlci5uZXh0KGN0eCksXG4gICAgICAgIGVycm9yOiBlcnJvciA9PiBvYnNlcnZlci5lcnJvcihlcnJvciksXG4gICAgICAgIGNvbXBsZXRlOiAoKSA9PiBvYnNlcnZlci5jb21wbGV0ZSgpXG4gICAgICB9KTtcblxuICAgICAgb2JzZXJ2ZXIuYWRkKGNoaWxkU3Vic2NyaXB0aW9uKTtcbiAgICB9KTtcbiAgfVxufVxuIl19