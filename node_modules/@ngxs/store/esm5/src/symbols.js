/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable, InjectionToken } from '@angular/core';
import { DispatchOutsideZoneNgxsExecutionStrategy } from './execution/dispatch-outside-zone-ngxs-execution-strategy';
/** @type {?} */
export var ROOT_STATE_TOKEN = new InjectionToken('ROOT_STATE_TOKEN');
/** @type {?} */
export var FEATURE_STATE_TOKEN = new InjectionToken('FEATURE_STATE_TOKEN');
/** @type {?} */
export var NGXS_PLUGINS = new InjectionToken('NGXS_PLUGINS');
/** @type {?} */
export var META_KEY = 'NGXS_META';
/** @type {?} */
export var META_OPTIONS_KEY = 'NGXS_OPTIONS_META';
/** @type {?} */
export var SELECTOR_META_KEY = 'NGXS_SELECTOR_META';
/**
 * The NGXS config settings.
 */
var NgxsConfig = /** @class */ (function () {
    function NgxsConfig() {
        /**
         * Defining the default state before module initialization
         * This is convenient if we need to create a define our own set of states.
         * @deprecated will be removed after v4
         * (default: {})
         */
        this.defaultsState = {};
        /**
         * Defining shared selector options
         */
        this.selectorOptions = {
            injectContainerState: true,
            // TODO: default is true in v3, will change in v4
            suppressErrors: true // TODO: default is true in v3, will change in v4
        };
        this.compatibility = {
            strictContentSecurityPolicy: false
        };
        this.executionStrategy = DispatchOutsideZoneNgxsExecutionStrategy;
    }
    NgxsConfig.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    NgxsConfig.ctorParameters = function () { return []; };
    return NgxsConfig;
}());
export { NgxsConfig };
if (false) {
    /**
     * Run in development mode. This will add additional debugging features:
     * - Object.freeze on the state and actions to guarantee immutability
     * (default: false)
     *
     * Note: this property will be accounted only in development mode when using the Ivy compiler.
     * It makes sense to use it only during development to ensure there're no state mutations.
     * When building for production, the Object.freeze will be tree-shaken away.
     * @type {?}
     */
    NgxsConfig.prototype.developmentMode;
    /** @type {?} */
    NgxsConfig.prototype.compatibility;
    /**
     * Determines the execution context to perform async operations inside. An implementation can be
     * provided to override the default behaviour where the async operations are run
     * outside Angular's zone but all observable behaviours of NGXS are run back inside Angular's zone.
     * These observable behaviours are from:
     *   `\@Select(...)`, `store.select(...)`, `actions.subscribe(...)` or `store.dispatch(...).subscribe(...)`
     * Every `zone.run` causes Angular to run change detection on the whole tree (`app.tick()`) so of your
     * application doesn't rely on zone.js running change detection then you can switch to the
     * `NoopNgxsExecutionStrategy` that doesn't interact with zones.
     * (default: null)
     * @type {?}
     */
    NgxsConfig.prototype.executionStrategy;
    /**
     * Defining the default state before module initialization
     * This is convenient if we need to create a define our own set of states.
     * @deprecated will be removed after v4
     * (default: {})
     * @type {?}
     */
    NgxsConfig.prototype.defaultsState;
    /**
     * Defining shared selector options
     * @type {?}
     */
    NgxsConfig.prototype.selectorOptions;
}
/**
 * State context provided to the actions in the state.
 * @record
 * @template T
 */
export function StateContext() { }
if (false) {
    /**
     * Get the current state.
     * @return {?}
     */
    StateContext.prototype.getState = function () { };
    /**
     * Reset the state to a new value.
     * @param {?} val
     * @return {?}
     */
    StateContext.prototype.setState = function (val) { };
    /**
     * Patch the existing state with the provided value.
     * @param {?} val
     * @return {?}
     */
    StateContext.prototype.patchState = function (val) { };
    /**
     * Dispatch a new action and return the dispatched observable.
     * @param {?} actions
     * @return {?}
     */
    StateContext.prototype.dispatch = function (actions) { };
}
/**
 * Plugin interface
 * @record
 */
export function NgxsPlugin() { }
if (false) {
    /**
     * Handle the state/action before its submitted to the state handlers.
     * @param {?} state
     * @param {?} action
     * @param {?} next
     * @return {?}
     */
    NgxsPlugin.prototype.handle = function (state, action, next) { };
}
/**
 * Options that can be provided to the store.
 * @record
 * @template T
 */
export function StoreOptions() { }
if (false) {
    /**
     * Name of the state. Required.
     * @type {?}
     */
    StoreOptions.prototype.name;
    /**
     * Default values for the state. If not provided, uses empty object.
     * @type {?|undefined}
     */
    StoreOptions.prototype.defaults;
    /**
     * Sub states for the given state.
     * @type {?|undefined}
     */
    StoreOptions.prototype.children;
}
/**
 * Represents a basic change from a previous to a new value for a single state instance.
 * Passed as a value in a NgxsSimpleChanges object to the ngxsOnChanges hook.
 * @template T
 */
var /**
 * Represents a basic change from a previous to a new value for a single state instance.
 * Passed as a value in a NgxsSimpleChanges object to the ngxsOnChanges hook.
 * @template T
 */
NgxsSimpleChange = /** @class */ (function () {
    function NgxsSimpleChange(previousValue, currentValue, firstChange) {
        this.previousValue = previousValue;
        this.currentValue = currentValue;
        this.firstChange = firstChange;
    }
    return NgxsSimpleChange;
}());
/**
 * Represents a basic change from a previous to a new value for a single state instance.
 * Passed as a value in a NgxsSimpleChanges object to the ngxsOnChanges hook.
 * @template T
 */
export { NgxsSimpleChange };
if (false) {
    /** @type {?} */
    NgxsSimpleChange.prototype.previousValue;
    /** @type {?} */
    NgxsSimpleChange.prototype.currentValue;
    /** @type {?} */
    NgxsSimpleChange.prototype.firstChange;
}
/**
 * On init interface
 * @record
 */
export function NgxsOnInit() { }
if (false) {
    /**
     * @param {?} ctx
     * @return {?}
     */
    NgxsOnInit.prototype.ngxsOnInit = function (ctx) { };
}
/**
 * On change interface
 * @record
 */
export function NgxsOnChanges() { }
if (false) {
    /**
     * @param {?} change
     * @return {?}
     */
    NgxsOnChanges.prototype.ngxsOnChanges = function (change) { };
}
/**
 * After bootstrap interface
 * @record
 */
export function NgxsAfterBootstrap() { }
if (false) {
    /**
     * @param {?} ctx
     * @return {?}
     */
    NgxsAfterBootstrap.prototype.ngxsAfterBootstrap = function (ctx) { };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3ltYm9scy5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuZ3hzL3N0b3JlLyIsInNvdXJjZXMiOlsic3JjL3N5bWJvbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsY0FBYyxFQUFRLE1BQU0sZUFBZSxDQUFDO0FBTWpFLE9BQU8sRUFBRSx3Q0FBd0MsRUFBRSxNQUFNLDJEQUEyRCxDQUFDOztBQUdySCxNQUFNLEtBQU8sZ0JBQWdCLEdBQUcsSUFBSSxjQUFjLENBQU0sa0JBQWtCLENBQUM7O0FBQzNFLE1BQU0sS0FBTyxtQkFBbUIsR0FBRyxJQUFJLGNBQWMsQ0FBTSxxQkFBcUIsQ0FBQzs7QUFDakYsTUFBTSxLQUFPLFlBQVksR0FBRyxJQUFJLGNBQWMsQ0FBQyxjQUFjLENBQUM7O0FBRTlELE1BQU0sS0FBTyxRQUFRLEdBQUcsV0FBVzs7QUFDbkMsTUFBTSxLQUFPLGdCQUFnQixHQUFHLG1CQUFtQjs7QUFDbkQsTUFBTSxLQUFPLGlCQUFpQixHQUFHLG9CQUFvQjs7OztBQVdyRDtJQStDRTs7Ozs7OztRQVRBLGtCQUFhLEdBQWdCLEVBQUUsQ0FBQzs7OztRQUloQyxvQkFBZSxHQUEwQjtZQUN2QyxvQkFBb0IsRUFBRSxJQUFJOztZQUMxQixjQUFjLEVBQUUsSUFBSSxDQUFDLGlEQUFpRDtTQUN2RSxDQUFDO1FBR0EsSUFBSSxDQUFDLGFBQWEsR0FBRztZQUNuQiwyQkFBMkIsRUFBRSxLQUFLO1NBQ25DLENBQUM7UUFDRixJQUFJLENBQUMsaUJBQWlCLEdBQUcsd0NBQXdDLENBQUM7SUFDcEUsQ0FBQzs7Z0JBcERGLFVBQVU7Ozs7SUFxRFgsaUJBQUM7Q0FBQSxBQXJERCxJQXFEQztTQXBEWSxVQUFVOzs7Ozs7Ozs7Ozs7SUFVckIscUNBQXlCOztJQUN6QixtQ0FPRTs7Ozs7Ozs7Ozs7OztJQVlGLHVDQUErQzs7Ozs7Ozs7SUFPL0MsbUNBQWdDOzs7OztJQUloQyxxQ0FHRTs7Ozs7OztBQWVKLGtDQW9CQzs7Ozs7O0lBaEJDLGtEQUFjOzs7Ozs7SUFLZCxxREFBdUM7Ozs7OztJQUt2Qyx1REFBK0I7Ozs7OztJQUsvQix5REFBaUQ7Ozs7OztBQVFuRCxnQ0FLQzs7Ozs7Ozs7O0lBREMsaUVBQTZEOzs7Ozs7O0FBTS9ELGtDQWVDOzs7Ozs7SUFYQyw0QkFBNkI7Ozs7O0lBSzdCLGdDQUFhOzs7OztJQUtiLGdDQUF3Qjs7Ozs7OztBQU8xQjs7Ozs7O0lBQ0UsMEJBQ2tCLGFBQWdCLEVBQ2hCLFlBQWUsRUFDZixXQUFvQjtRQUZwQixrQkFBYSxHQUFiLGFBQWEsQ0FBRztRQUNoQixpQkFBWSxHQUFaLFlBQVksQ0FBRztRQUNmLGdCQUFXLEdBQVgsV0FBVyxDQUFTO0lBQ25DLENBQUM7SUFDTix1QkFBQztBQUFELENBQUMsQUFORCxJQU1DOzs7Ozs7Ozs7SUFKRyx5Q0FBZ0M7O0lBQ2hDLHdDQUErQjs7SUFDL0IsdUNBQW9DOzs7Ozs7QUFPeEMsZ0NBRUM7Ozs7OztJQURDLHFEQUF5Qzs7Ozs7O0FBTTNDLG1DQUVDOzs7Ozs7SUFEQyw4REFBOEM7Ozs7OztBQU1oRCx3Q0FFQzs7Ozs7O0lBREMscUVBQWlEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgSW5qZWN0aW9uVG9rZW4sIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgUGxhaW5PYmplY3QsIFN0YXRlQ2xhc3MgfSBmcm9tICdAbmd4cy9zdG9yZS9pbnRlcm5hbHMnO1xuaW1wb3J0IHsgU2hhcmVkU2VsZWN0b3JPcHRpb25zIH0gZnJvbSAnLi9pbnRlcm5hbC9pbnRlcm5hbHMnO1xuaW1wb3J0IHsgTmd4c0V4ZWN1dGlvblN0cmF0ZWd5IH0gZnJvbSAnLi9leGVjdXRpb24vc3ltYm9scyc7XG5pbXBvcnQgeyBEaXNwYXRjaE91dHNpZGVab25lTmd4c0V4ZWN1dGlvblN0cmF0ZWd5IH0gZnJvbSAnLi9leGVjdXRpb24vZGlzcGF0Y2gtb3V0c2lkZS16b25lLW5neHMtZXhlY3V0aW9uLXN0cmF0ZWd5JztcbmltcG9ydCB7IFN0YXRlVG9rZW4gfSBmcm9tICcuL3N0YXRlLXRva2VuL3N0YXRlLXRva2VuJztcblxuZXhwb3J0IGNvbnN0IFJPT1RfU1RBVEVfVE9LRU4gPSBuZXcgSW5qZWN0aW9uVG9rZW48YW55PignUk9PVF9TVEFURV9UT0tFTicpO1xuZXhwb3J0IGNvbnN0IEZFQVRVUkVfU1RBVEVfVE9LRU4gPSBuZXcgSW5qZWN0aW9uVG9rZW48YW55PignRkVBVFVSRV9TVEFURV9UT0tFTicpO1xuZXhwb3J0IGNvbnN0IE5HWFNfUExVR0lOUyA9IG5ldyBJbmplY3Rpb25Ub2tlbignTkdYU19QTFVHSU5TJyk7XG5cbmV4cG9ydCBjb25zdCBNRVRBX0tFWSA9ICdOR1hTX01FVEEnO1xuZXhwb3J0IGNvbnN0IE1FVEFfT1BUSU9OU19LRVkgPSAnTkdYU19PUFRJT05TX01FVEEnO1xuZXhwb3J0IGNvbnN0IFNFTEVDVE9SX01FVEFfS0VZID0gJ05HWFNfU0VMRUNUT1JfTUVUQSc7XG5cbmV4cG9ydCB0eXBlIE5neHNMaWZlQ3ljbGUgPSBQYXJ0aWFsPE5neHNPbkNoYW5nZXM+ICZcbiAgUGFydGlhbDxOZ3hzT25Jbml0PiAmXG4gIFBhcnRpYWw8Tmd4c0FmdGVyQm9vdHN0cmFwPjtcblxuZXhwb3J0IHR5cGUgTmd4c1BsdWdpbkZuID0gKHN0YXRlOiBhbnksIG11dGF0aW9uOiBhbnksIG5leHQ6IE5neHNOZXh0UGx1Z2luRm4pID0+IGFueTtcblxuLyoqXG4gKiBUaGUgTkdYUyBjb25maWcgc2V0dGluZ3MuXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBOZ3hzQ29uZmlnIHtcbiAgLyoqXG4gICAqIFJ1biBpbiBkZXZlbG9wbWVudCBtb2RlLiBUaGlzIHdpbGwgYWRkIGFkZGl0aW9uYWwgZGVidWdnaW5nIGZlYXR1cmVzOlxuICAgKiAtIE9iamVjdC5mcmVlemUgb24gdGhlIHN0YXRlIGFuZCBhY3Rpb25zIHRvIGd1YXJhbnRlZSBpbW11dGFiaWxpdHlcbiAgICogKGRlZmF1bHQ6IGZhbHNlKVxuICAgKlxuICAgKiBOb3RlOiB0aGlzIHByb3BlcnR5IHdpbGwgYmUgYWNjb3VudGVkIG9ubHkgaW4gZGV2ZWxvcG1lbnQgbW9kZSB3aGVuIHVzaW5nIHRoZSBJdnkgY29tcGlsZXIuXG4gICAqIEl0IG1ha2VzIHNlbnNlIHRvIHVzZSBpdCBvbmx5IGR1cmluZyBkZXZlbG9wbWVudCB0byBlbnN1cmUgdGhlcmUncmUgbm8gc3RhdGUgbXV0YXRpb25zLlxuICAgKiBXaGVuIGJ1aWxkaW5nIGZvciBwcm9kdWN0aW9uLCB0aGUgT2JqZWN0LmZyZWV6ZSB3aWxsIGJlIHRyZWUtc2hha2VuIGF3YXkuXG4gICAqL1xuICBkZXZlbG9wbWVudE1vZGU6IGJvb2xlYW47XG4gIGNvbXBhdGliaWxpdHk6IHtcbiAgICAvKipcbiAgICAgKiBTdXBwb3J0IGEgc3RyaWN0IENvbnRlbnQgU2VjdXJpdHkgUG9saWN5LlxuICAgICAqIFRoaXMgd2lsbCBjaXJjdW12ZW50IHNvbWUgb3B0aW1pc2F0aW9ucyB0aGF0IHZpb2xhdGUgYSBzdHJpY3QgQ1NQIHRocm91Z2ggdGhlIHVzZSBvZiBgbmV3IEZ1bmN0aW9uKC4uLilgLlxuICAgICAqIChkZWZhdWx0OiBmYWxzZSlcbiAgICAgKi9cbiAgICBzdHJpY3RDb250ZW50U2VjdXJpdHlQb2xpY3k6IGJvb2xlYW47XG4gIH07XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBleGVjdXRpb24gY29udGV4dCB0byBwZXJmb3JtIGFzeW5jIG9wZXJhdGlvbnMgaW5zaWRlLiBBbiBpbXBsZW1lbnRhdGlvbiBjYW4gYmVcbiAgICogcHJvdmlkZWQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3VyIHdoZXJlIHRoZSBhc3luYyBvcGVyYXRpb25zIGFyZSBydW5cbiAgICogb3V0c2lkZSBBbmd1bGFyJ3Mgem9uZSBidXQgYWxsIG9ic2VydmFibGUgYmVoYXZpb3VycyBvZiBOR1hTIGFyZSBydW4gYmFjayBpbnNpZGUgQW5ndWxhcidzIHpvbmUuXG4gICAqIFRoZXNlIG9ic2VydmFibGUgYmVoYXZpb3VycyBhcmUgZnJvbTpcbiAgICogICBgQFNlbGVjdCguLi4pYCwgYHN0b3JlLnNlbGVjdCguLi4pYCwgYGFjdGlvbnMuc3Vic2NyaWJlKC4uLilgIG9yIGBzdG9yZS5kaXNwYXRjaCguLi4pLnN1YnNjcmliZSguLi4pYFxuICAgKiBFdmVyeSBgem9uZS5ydW5gIGNhdXNlcyBBbmd1bGFyIHRvIHJ1biBjaGFuZ2UgZGV0ZWN0aW9uIG9uIHRoZSB3aG9sZSB0cmVlIChgYXBwLnRpY2soKWApIHNvIG9mIHlvdXJcbiAgICogYXBwbGljYXRpb24gZG9lc24ndCByZWx5IG9uIHpvbmUuanMgcnVubmluZyBjaGFuZ2UgZGV0ZWN0aW9uIHRoZW4geW91IGNhbiBzd2l0Y2ggdG8gdGhlXG4gICAqIGBOb29wTmd4c0V4ZWN1dGlvblN0cmF0ZWd5YCB0aGF0IGRvZXNuJ3QgaW50ZXJhY3Qgd2l0aCB6b25lcy5cbiAgICogKGRlZmF1bHQ6IG51bGwpXG4gICAqL1xuICBleGVjdXRpb25TdHJhdGVneTogVHlwZTxOZ3hzRXhlY3V0aW9uU3RyYXRlZ3k+O1xuICAvKipcbiAgICogRGVmaW5pbmcgdGhlIGRlZmF1bHQgc3RhdGUgYmVmb3JlIG1vZHVsZSBpbml0aWFsaXphdGlvblxuICAgKiBUaGlzIGlzIGNvbnZlbmllbnQgaWYgd2UgbmVlZCB0byBjcmVhdGUgYSBkZWZpbmUgb3VyIG93biBzZXQgb2Ygc3RhdGVzLlxuICAgKiBAZGVwcmVjYXRlZCB3aWxsIGJlIHJlbW92ZWQgYWZ0ZXIgdjRcbiAgICogKGRlZmF1bHQ6IHt9KVxuICAgKi9cbiAgZGVmYXVsdHNTdGF0ZTogUGxhaW5PYmplY3QgPSB7fTtcbiAgLyoqXG4gICAqIERlZmluaW5nIHNoYXJlZCBzZWxlY3RvciBvcHRpb25zXG4gICAqL1xuICBzZWxlY3Rvck9wdGlvbnM6IFNoYXJlZFNlbGVjdG9yT3B0aW9ucyA9IHtcbiAgICBpbmplY3RDb250YWluZXJTdGF0ZTogdHJ1ZSwgLy8gVE9ETzogZGVmYXVsdCBpcyB0cnVlIGluIHYzLCB3aWxsIGNoYW5nZSBpbiB2NFxuICAgIHN1cHByZXNzRXJyb3JzOiB0cnVlIC8vIFRPRE86IGRlZmF1bHQgaXMgdHJ1ZSBpbiB2Mywgd2lsbCBjaGFuZ2UgaW4gdjRcbiAgfTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNvbXBhdGliaWxpdHkgPSB7XG4gICAgICBzdHJpY3RDb250ZW50U2VjdXJpdHlQb2xpY3k6IGZhbHNlXG4gICAgfTtcbiAgICB0aGlzLmV4ZWN1dGlvblN0cmF0ZWd5ID0gRGlzcGF0Y2hPdXRzaWRlWm9uZU5neHNFeGVjdXRpb25TdHJhdGVneTtcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBTdGF0ZU9wZXJhdG9yPFQ+ID0gKGV4aXN0aW5nOiBSZWFkb25seTxUPikgPT4gVDtcblxuLyoqXG4gKiBTdGF0ZSBjb250ZXh0IHByb3ZpZGVkIHRvIHRoZSBhY3Rpb25zIGluIHRoZSBzdGF0ZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdGF0ZUNvbnRleHQ8VD4ge1xuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHN0YXRlLlxuICAgKi9cbiAgZ2V0U3RhdGUoKTogVDtcblxuICAvKipcbiAgICogUmVzZXQgdGhlIHN0YXRlIHRvIGEgbmV3IHZhbHVlLlxuICAgKi9cbiAgc2V0U3RhdGUodmFsOiBUIHwgU3RhdGVPcGVyYXRvcjxUPik6IFQ7XG5cbiAgLyoqXG4gICAqIFBhdGNoIHRoZSBleGlzdGluZyBzdGF0ZSB3aXRoIHRoZSBwcm92aWRlZCB2YWx1ZS5cbiAgICovXG4gIHBhdGNoU3RhdGUodmFsOiBQYXJ0aWFsPFQ+KTogVDtcblxuICAvKipcbiAgICogRGlzcGF0Y2ggYSBuZXcgYWN0aW9uIGFuZCByZXR1cm4gdGhlIGRpc3BhdGNoZWQgb2JzZXJ2YWJsZS5cbiAgICovXG4gIGRpc3BhdGNoKGFjdGlvbnM6IGFueSB8IGFueVtdKTogT2JzZXJ2YWJsZTx2b2lkPjtcbn1cblxuZXhwb3J0IHR5cGUgTmd4c05leHRQbHVnaW5GbiA9IChzdGF0ZTogYW55LCBtdXRhdGlvbjogYW55KSA9PiBhbnk7XG5cbi8qKlxuICogUGx1Z2luIGludGVyZmFjZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5neHNQbHVnaW4ge1xuICAvKipcbiAgICogSGFuZGxlIHRoZSBzdGF0ZS9hY3Rpb24gYmVmb3JlIGl0cyBzdWJtaXR0ZWQgdG8gdGhlIHN0YXRlIGhhbmRsZXJzLlxuICAgKi9cbiAgaGFuZGxlKHN0YXRlOiBhbnksIGFjdGlvbjogYW55LCBuZXh0OiBOZ3hzTmV4dFBsdWdpbkZuKTogYW55O1xufVxuXG4vKipcbiAqIE9wdGlvbnMgdGhhdCBjYW4gYmUgcHJvdmlkZWQgdG8gdGhlIHN0b3JlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN0b3JlT3B0aW9uczxUPiB7XG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSBzdGF0ZS4gUmVxdWlyZWQuXG4gICAqL1xuICBuYW1lOiBzdHJpbmcgfCBTdGF0ZVRva2VuPFQ+O1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHZhbHVlcyBmb3IgdGhlIHN0YXRlLiBJZiBub3QgcHJvdmlkZWQsIHVzZXMgZW1wdHkgb2JqZWN0LlxuICAgKi9cbiAgZGVmYXVsdHM/OiBUO1xuXG4gIC8qKlxuICAgKiBTdWIgc3RhdGVzIGZvciB0aGUgZ2l2ZW4gc3RhdGUuXG4gICAqL1xuICBjaGlsZHJlbj86IFN0YXRlQ2xhc3NbXTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgYmFzaWMgY2hhbmdlIGZyb20gYSBwcmV2aW91cyB0byBhIG5ldyB2YWx1ZSBmb3IgYSBzaW5nbGUgc3RhdGUgaW5zdGFuY2UuXG4gKiBQYXNzZWQgYXMgYSB2YWx1ZSBpbiBhIE5neHNTaW1wbGVDaGFuZ2VzIG9iamVjdCB0byB0aGUgbmd4c09uQ2hhbmdlcyBob29rLlxuICovXG5leHBvcnQgY2xhc3MgTmd4c1NpbXBsZUNoYW5nZTxUID0gYW55PiB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyByZWFkb25seSBwcmV2aW91c1ZhbHVlOiBULFxuICAgIHB1YmxpYyByZWFkb25seSBjdXJyZW50VmFsdWU6IFQsXG4gICAgcHVibGljIHJlYWRvbmx5IGZpcnN0Q2hhbmdlOiBib29sZWFuXG4gICkge31cbn1cblxuLyoqXG4gKiBPbiBpbml0IGludGVyZmFjZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5neHNPbkluaXQge1xuICBuZ3hzT25Jbml0KGN0eDogU3RhdGVDb250ZXh0PGFueT4pOiB2b2lkO1xufVxuXG4vKipcbiAqIE9uIGNoYW5nZSBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZ3hzT25DaGFuZ2VzIHtcbiAgbmd4c09uQ2hhbmdlcyhjaGFuZ2U6IE5neHNTaW1wbGVDaGFuZ2UpOiB2b2lkO1xufVxuXG4vKipcbiAqIEFmdGVyIGJvb3RzdHJhcCBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZ3hzQWZ0ZXJCb290c3RyYXAge1xuICBuZ3hzQWZ0ZXJCb290c3RyYXAoY3R4OiBTdGF0ZUNvbnRleHQ8YW55Pik6IHZvaWQ7XG59XG5cbmV4cG9ydCB0eXBlIE5neHNNb2R1bGVPcHRpb25zID0gUGFydGlhbDxOZ3hzQ29uZmlnPjtcblxuLyoqIEBpbnRlcm5hbCAqL1xuZGVjbGFyZSBnbG9iYWwge1xuICBjb25zdCBuZ0Rldk1vZGU6IGJvb2xlYW47XG59XG4iXX0=