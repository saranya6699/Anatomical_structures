/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
// tslint:disable:unified-signatures
import { Inject, Injectable, Optional } from '@angular/core';
import { of, throwError, queueScheduler } from 'rxjs';
import { catchError, distinctUntilChanged, map, shareReplay, take, observeOn } from 'rxjs/operators';
import { INITIAL_STATE_TOKEN } from '@ngxs/store/internals';
import { InternalNgxsExecutionStrategy } from './execution/internal-ngxs-execution-strategy';
import { InternalStateOperations } from './internal/state-operations';
import { getRootSelectorFactory } from './utils/selector-utils';
import { StateStream } from './internal/state-stream';
import { leaveNgxs } from './operators/leave-ngxs';
import { NgxsConfig } from './symbols';
import { StateFactory } from './internal/state-factory';
var Store = /** @class */ (function () {
    function Store(_stateStream, _internalStateOperations, _config, _internalExecutionStrategy, _stateFactory, initialStateValue) {
        this._stateStream = _stateStream;
        this._internalStateOperations = _internalStateOperations;
        this._config = _config;
        this._internalExecutionStrategy = _internalExecutionStrategy;
        this._stateFactory = _stateFactory;
        /**
         * This is a derived state stream that leaves NGXS execution strategy to emit state changes within the Angular zone,
         * because state is being changed actually within the `<root>` zone, see `InternalDispatcher#dispatchSingle`.
         * All selects would use this stream, and it would call leave only once for any state change across all active selectors.
         */
        this._selectableStateStream = this._stateStream.pipe(observeOn(queueScheduler), leaveNgxs(this._internalExecutionStrategy), shareReplay({ bufferSize: 1, refCount: true }));
        this.initStateStream(initialStateValue);
    }
    /**
     * Dispatches event(s).
     */
    /**
     * Dispatches event(s).
     * @param {?} actionOrActions
     * @return {?}
     */
    Store.prototype.dispatch = /**
     * Dispatches event(s).
     * @param {?} actionOrActions
     * @return {?}
     */
    function (actionOrActions) {
        return this._internalStateOperations.getRootStateOperations().dispatch(actionOrActions);
    };
    /**
     * @param {?} selector
     * @return {?}
     */
    Store.prototype.select = /**
     * @param {?} selector
     * @return {?}
     */
    function (selector) {
        var _this = this;
        /** @type {?} */
        var selectorFn = this.getStoreBoundSelectorFn(selector);
        return this._selectableStateStream.pipe(map(selectorFn), catchError((/**
         * @param {?} err
         * @return {?}
         */
        function (err) {
            // if error is TypeError we swallow it to prevent usual errors with property access
            var suppressErrors = _this._config.selectorOptions.suppressErrors;
            if (err instanceof TypeError && suppressErrors) {
                return of(undefined);
            }
            // rethrow other errors
            return throwError(err);
        })), distinctUntilChanged(), leaveNgxs(this._internalExecutionStrategy));
    };
    /**
     * @param {?} selector
     * @return {?}
     */
    Store.prototype.selectOnce = /**
     * @param {?} selector
     * @return {?}
     */
    function (selector) {
        return this.select(selector).pipe(take(1));
    };
    /**
     * @param {?} selector
     * @return {?}
     */
    Store.prototype.selectSnapshot = /**
     * @param {?} selector
     * @return {?}
     */
    function (selector) {
        /** @type {?} */
        var selectorFn = this.getStoreBoundSelectorFn(selector);
        return selectorFn(this._stateStream.getValue());
    };
    /**
     * Allow the user to subscribe to the root of the state
     */
    /**
     * Allow the user to subscribe to the root of the state
     * @param {?=} fn
     * @return {?}
     */
    Store.prototype.subscribe = /**
     * Allow the user to subscribe to the root of the state
     * @param {?=} fn
     * @return {?}
     */
    function (fn) {
        return this._selectableStateStream
            .pipe(leaveNgxs(this._internalExecutionStrategy))
            .subscribe(fn);
    };
    /**
     * Return the raw value of the state.
     */
    /**
     * Return the raw value of the state.
     * @return {?}
     */
    Store.prototype.snapshot = /**
     * Return the raw value of the state.
     * @return {?}
     */
    function () {
        return this._internalStateOperations.getRootStateOperations().getState();
    };
    /**
     * Reset the state to a specific point in time. This method is useful
     * for plugin's who need to modify the state directly or unit testing.
     */
    /**
     * Reset the state to a specific point in time. This method is useful
     * for plugin's who need to modify the state directly or unit testing.
     * @param {?} state
     * @return {?}
     */
    Store.prototype.reset = /**
     * Reset the state to a specific point in time. This method is useful
     * for plugin's who need to modify the state directly or unit testing.
     * @param {?} state
     * @return {?}
     */
    function (state) {
        return this._internalStateOperations.getRootStateOperations().setState(state);
    };
    /**
     * @private
     * @param {?} selector
     * @return {?}
     */
    Store.prototype.getStoreBoundSelectorFn = /**
     * @private
     * @param {?} selector
     * @return {?}
     */
    function (selector) {
        /** @type {?} */
        var makeSelectorFn = getRootSelectorFactory(selector);
        /** @type {?} */
        var runtimeContext = this._stateFactory.getRuntimeSelectorContext();
        return makeSelectorFn(runtimeContext);
    };
    /**
     * @private
     * @param {?} initialStateValue
     * @return {?}
     */
    Store.prototype.initStateStream = /**
     * @private
     * @param {?} initialStateValue
     * @return {?}
     */
    function (initialStateValue) {
        /** @type {?} */
        var value = this._stateStream.value;
        /** @type {?} */
        var storeIsEmpty = !value || Object.keys(value).length === 0;
        if (storeIsEmpty) {
            /** @type {?} */
            var defaultStateNotEmpty = Object.keys(this._config.defaultsState).length > 0;
            /** @type {?} */
            var storeValues = defaultStateNotEmpty
                ? tslib_1.__assign({}, this._config.defaultsState, initialStateValue) : initialStateValue;
            this._stateStream.next(storeValues);
        }
    };
    Store.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    Store.ctorParameters = function () { return [
        { type: StateStream },
        { type: InternalStateOperations },
        { type: NgxsConfig },
        { type: InternalNgxsExecutionStrategy },
        { type: StateFactory },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [INITIAL_STATE_TOKEN,] }] }
    ]; };
    return Store;
}());
export { Store };
if (false) {
    /**
     * This is a derived state stream that leaves NGXS execution strategy to emit state changes within the Angular zone,
     * because state is being changed actually within the `<root>` zone, see `InternalDispatcher#dispatchSingle`.
     * All selects would use this stream, and it would call leave only once for any state change across all active selectors.
     * @type {?}
     * @private
     */
    Store.prototype._selectableStateStream;
    /**
     * @type {?}
     * @private
     */
    Store.prototype._stateStream;
    /**
     * @type {?}
     * @private
     */
    Store.prototype._internalStateOperations;
    /**
     * @type {?}
     * @private
     */
    Store.prototype._config;
    /**
     * @type {?}
     * @private
     */
    Store.prototype._internalExecutionStrategy;
    /**
     * @type {?}
     * @private
     */
    Store.prototype._stateFactory;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RvcmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Abmd4cy9zdG9yZS8iLCJzb3VyY2VzIjpbInNyYy9zdG9yZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQSxPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQVEsTUFBTSxlQUFlLENBQUM7QUFDbkUsT0FBTyxFQUFjLEVBQUUsRUFBZ0IsVUFBVSxFQUFFLGNBQWMsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNoRixPQUFPLEVBQ0wsVUFBVSxFQUNWLG9CQUFvQixFQUNwQixHQUFHLEVBQ0gsV0FBVyxFQUNYLElBQUksRUFDSixTQUFTLEVBQ1YsTUFBTSxnQkFBZ0IsQ0FBQztBQUN4QixPQUFPLEVBQUUsbUJBQW1CLEVBQWUsTUFBTSx1QkFBdUIsQ0FBQztBQUV6RSxPQUFPLEVBQUUsNkJBQTZCLEVBQUUsTUFBTSw4Q0FBOEMsQ0FBQztBQUM3RixPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUN0RSxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUNoRSxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDdEQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ25ELE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFFdkMsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBRXhEO0lBYUUsZUFDVSxZQUF5QixFQUN6Qix3QkFBaUQsRUFDakQsT0FBbUIsRUFDbkIsMEJBQXlELEVBQ3pELGFBQTJCLEVBR25DLGlCQUFzQjtRQVBkLGlCQUFZLEdBQVosWUFBWSxDQUFhO1FBQ3pCLDZCQUF3QixHQUF4Qix3QkFBd0IsQ0FBeUI7UUFDakQsWUFBTyxHQUFQLE9BQU8sQ0FBWTtRQUNuQiwrQkFBMEIsR0FBMUIsMEJBQTBCLENBQStCO1FBQ3pELGtCQUFh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QUksTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQztRQUN2RSxJQUFJLFlBQVksRUFBRTs7Z0JBQ1Ysb0JBQW9CLEdBQVksTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDOztnQkFDbEYsV0FBVyxHQUFnQixvQkFBb0I7Z0JBQ25ELENBQUMsc0JBQU0sSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLEVBQUssaUJBQWlCLEVBQ3ZELENBQUMsQ0FBQyxpQkFBaUI7WUFFckIsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7U0FDckM7SUFDSCxDQUFDOztnQkExSEYsVUFBVTs7OztnQkFORixXQUFXO2dCQUZYLHVCQUF1QjtnQkFJdkIsVUFBVTtnQkFMViw2QkFBNkI7Z0JBTzdCLFlBQVk7Z0RBcUJoQixRQUFRLFlBQ1IsTUFBTSxTQUFDLG1CQUFtQjs7SUF1Ry9CLFlBQUM7Q0FBQSxBQTNIRCxJQTJIQztTQTFIWSxLQUFLOzs7Ozs7Ozs7SUFNaEIsdUNBSUU7Ozs7O0lBR0EsNkJBQWlDOzs7OztJQUNqQyx5Q0FBeUQ7Ozs7O0lBQ3pELHdCQUEyQjs7Ozs7SUFDM0IsMkNBQWlFOzs7OztJQUNqRSw4QkFBbUMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0c2xpbnQ6ZGlzYWJsZTp1bmlmaWVkLXNpZ25hdHVyZXNcbmltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSwgT3B0aW9uYWwsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIG9mLCBTdWJzY3JpcHRpb24sIHRocm93RXJyb3IsIHF1ZXVlU2NoZWR1bGVyIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQge1xuICBjYXRjaEVycm9yLFxuICBkaXN0aW5jdFVudGlsQ2hhbmdlZCxcbiAgbWFwLFxuICBzaGFyZVJlcGxheSxcbiAgdGFrZSxcbiAgb2JzZXJ2ZU9uXG59IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IElOSVRJQUxfU1RBVEVfVE9LRU4sIFBsYWluT2JqZWN0IH0gZnJvbSAnQG5neHMvc3RvcmUvaW50ZXJuYWxzJztcblxuaW1wb3J0IHsgSW50ZXJuYWxOZ3hzRXhlY3V0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL2V4ZWN1dGlvbi9pbnRlcm5hbC1uZ3hzLWV4ZWN1dGlvbi1zdHJhdGVneSc7XG5pbXBvcnQgeyBJbnRlcm5hbFN0YXRlT3BlcmF0aW9ucyB9IGZyb20gJy4vaW50ZXJuYWwvc3RhdGUtb3BlcmF0aW9ucyc7XG5pbXBvcnQgeyBnZXRSb290U2VsZWN0b3JGYWN0b3J5IH0gZnJvbSAnLi91dGlscy9zZWxlY3Rvci11dGlscyc7XG5pbXBvcnQgeyBTdGF0ZVN0cmVhbSB9IGZyb20gJy4vaW50ZXJuYWwvc3RhdGUtc3RyZWFtJztcbmltcG9ydCB7IGxlYXZlTmd4cyB9IGZyb20gJy4vb3BlcmF0b3JzL2xlYXZlLW5neHMnO1xuaW1wb3J0IHsgTmd4c0NvbmZpZyB9IGZyb20gJy4vc3ltYm9scyc7XG5pbXBvcnQgeyBTdGF0ZVRva2VuIH0gZnJvbSAnLi9zdGF0ZS10b2tlbi9zdGF0ZS10b2tlbic7XG5pbXBvcnQgeyBTdGF0ZUZhY3RvcnkgfSBmcm9tICcuL2ludGVybmFsL3N0YXRlLWZhY3RvcnknO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgU3RvcmUge1xuICAvKipcbiAgICogVGhpcyBpcyBhIGRlcml2ZWQgc3RhdGUgc3RyZWFtIHRoYXQgbGVhdmVzIE5HWFMgZXhlY3V0aW9uIHN0cmF0ZWd5IHRvIGVtaXQgc3RhdGUgY2hhbmdlcyB3aXRoaW4gdGhlIEFuZ3VsYXIgem9uZSxcbiAgICogYmVjYXVzZSBzdGF0ZSBpcyBiZWluZyBjaGFuZ2VkIGFjdHVhbGx5IHdpdGhpbiB0aGUgYDxyb290PmAgem9uZSwgc2VlIGBJbnRlcm5hbERpc3BhdGNoZXIjZGlzcGF0Y2hTaW5nbGVgLlxuICAgKiBBbGwgc2VsZWN0cyB3b3VsZCB1c2UgdGhpcyBzdHJlYW0sIGFuZCBpdCB3b3VsZCBjYWxsIGxlYXZlIG9ubHkgb25jZSBmb3IgYW55IHN0YXRlIGNoYW5nZSBhY3Jvc3MgYWxsIGFjdGl2ZSBzZWxlY3RvcnMuXG4gICAqL1xuICBwcml2YXRlIF9zZWxlY3RhYmxlU3RhdGVTdHJlYW0gPSB0aGlzLl9zdGF0ZVN0cmVhbS5waXBlKFxuICAgIG9ic2VydmVPbihxdWV1ZVNjaGVkdWxlciksXG4gICAgbGVhdmVOZ3hzKHRoaXMuX2ludGVybmFsRXhlY3V0aW9uU3RyYXRlZ3kpLFxuICAgIHNoYXJlUmVwbGF5KHsgYnVmZmVyU2l6ZTogMSwgcmVmQ291bnQ6IHRydWUgfSlcbiAgKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9zdGF0ZVN0cmVhbTogU3RhdGVTdHJlYW0sXG4gICAgcHJpdmF0ZSBfaW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnM6IEludGVybmFsU3RhdGVPcGVyYXRpb25zLFxuICAgIHByaXZhdGUgX2NvbmZpZzogTmd4c0NvbmZpZyxcbiAgICBwcml2YXRlIF9pbnRlcm5hbEV4ZWN1dGlvblN0cmF0ZWd5OiBJbnRlcm5hbE5neHNFeGVjdXRpb25TdHJhdGVneSxcbiAgICBwcml2YXRlIF9zdGF0ZUZhY3Rvcnk6IFN0YXRlRmFjdG9yeSxcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBJbmplY3QoSU5JVElBTF9TVEFURV9UT0tFTilcbiAgICBpbml0aWFsU3RhdGVWYWx1ZTogYW55XG4gICkge1xuICAgIHRoaXMuaW5pdFN0YXRlU3RyZWFtKGluaXRpYWxTdGF0ZVZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGV2ZW50KHMpLlxuICAgKi9cbiAgZGlzcGF0Y2goYWN0aW9uT3JBY3Rpb25zOiBhbnkgfCBhbnlbXSk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuX2ludGVybmFsU3RhdGVPcGVyYXRpb25zLmdldFJvb3RTdGF0ZU9wZXJhdGlvbnMoKS5kaXNwYXRjaChhY3Rpb25PckFjdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdHMgYSBzbGljZSBvZiBkYXRhIGZyb20gdGhlIHN0b3JlLlxuICAgKi9cbiAgc2VsZWN0PFQ+KHNlbGVjdG9yOiAoc3RhdGU6IGFueSwgLi4uc3RhdGVzOiBhbnlbXSkgPT4gVCk6IE9ic2VydmFibGU8VD47XG4gIHNlbGVjdDxUID0gYW55PihzZWxlY3Rvcjogc3RyaW5nIHwgVHlwZTxhbnk+KTogT2JzZXJ2YWJsZTxUPjtcbiAgc2VsZWN0PFQ+KHNlbGVjdG9yOiBTdGF0ZVRva2VuPFQ+KTogT2JzZXJ2YWJsZTxUPjtcbiAgc2VsZWN0KHNlbGVjdG9yOiBhbnkpOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgIGNvbnN0IHNlbGVjdG9yRm4gPSB0aGlzLmdldFN0b3JlQm91bmRTZWxlY3RvckZuKHNlbGVjdG9yKTtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0YWJsZVN0YXRlU3RyZWFtLnBpcGUoXG4gICAgICBtYXAoc2VsZWN0b3JGbiksXG4gICAgICBjYXRjaEVycm9yKChlcnI6IEVycm9yKTogT2JzZXJ2YWJsZTxuZXZlcj4gfCBPYnNlcnZhYmxlPHVuZGVmaW5lZD4gPT4ge1xuICAgICAgICAvLyBpZiBlcnJvciBpcyBUeXBlRXJyb3Igd2Ugc3dhbGxvdyBpdCB0byBwcmV2ZW50IHVzdWFsIGVycm9ycyB3aXRoIHByb3BlcnR5IGFjY2Vzc1xuICAgICAgICBjb25zdCB7IHN1cHByZXNzRXJyb3JzIH0gPSB0aGlzLl9jb25maWcuc2VsZWN0b3JPcHRpb25zO1xuXG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiYgc3VwcHJlc3NFcnJvcnMpIHtcbiAgICAgICAgICByZXR1cm4gb2YodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldGhyb3cgb3RoZXIgZXJyb3JzXG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yKGVycik7XG4gICAgICB9KSxcbiAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksXG4gICAgICBsZWF2ZU5neHModGhpcy5faW50ZXJuYWxFeGVjdXRpb25TdHJhdGVneSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdCBvbmUgc2xpY2Ugb2YgZGF0YSBmcm9tIHRoZSBzdG9yZS5cbiAgICovXG5cbiAgc2VsZWN0T25jZTxUPihzZWxlY3RvcjogKHN0YXRlOiBhbnksIC4uLnN0YXRlczogYW55W10pID0+IFQpOiBPYnNlcnZhYmxlPFQ+O1xuICBzZWxlY3RPbmNlPFQgPSBhbnk+KHNlbGVjdG9yOiBzdHJpbmcgfCBUeXBlPGFueT4pOiBPYnNlcnZhYmxlPFQ+O1xuICBzZWxlY3RPbmNlPFQ+KHNlbGVjdG9yOiBTdGF0ZVRva2VuPFQ+KTogT2JzZXJ2YWJsZTxUPjtcbiAgc2VsZWN0T25jZShzZWxlY3RvcjogYW55KTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Qoc2VsZWN0b3IpLnBpcGUodGFrZSgxKSk7XG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0IGEgc25hcHNob3QgZnJvbSB0aGUgc3RhdGUuXG4gICAqL1xuICBzZWxlY3RTbmFwc2hvdDxUPihzZWxlY3RvcjogKHN0YXRlOiBhbnksIC4uLnN0YXRlczogYW55W10pID0+IFQpOiBUO1xuICBzZWxlY3RTbmFwc2hvdDxUID0gYW55PihzZWxlY3Rvcjogc3RyaW5nIHwgVHlwZTxhbnk+KTogVDtcbiAgc2VsZWN0U25hcHNob3Q8VD4oc2VsZWN0b3I6IFN0YXRlVG9rZW48VD4pOiBUO1xuICBzZWxlY3RTbmFwc2hvdChzZWxlY3RvcjogYW55KTogYW55IHtcbiAgICBjb25zdCBzZWxlY3RvckZuID0gdGhpcy5nZXRTdG9yZUJvdW5kU2VsZWN0b3JGbihzZWxlY3Rvcik7XG4gICAgcmV0dXJuIHNlbGVjdG9yRm4odGhpcy5fc3RhdGVTdHJlYW0uZ2V0VmFsdWUoKSk7XG4gIH1cblxuICAvKipcbiAgICogQWxsb3cgdGhlIHVzZXIgdG8gc3Vic2NyaWJlIHRvIHRoZSByb290IG9mIHRoZSBzdGF0ZVxuICAgKi9cbiAgc3Vic2NyaWJlKGZuPzogKHZhbHVlOiBhbnkpID0+IHZvaWQpOiBTdWJzY3JpcHRpb24ge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3RhYmxlU3RhdGVTdHJlYW1cbiAgICAgIC5waXBlKGxlYXZlTmd4cyh0aGlzLl9pbnRlcm5hbEV4ZWN1dGlvblN0cmF0ZWd5KSlcbiAgICAgIC5zdWJzY3JpYmUoZm4pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgcmF3IHZhbHVlIG9mIHRoZSBzdGF0ZS5cbiAgICovXG4gIHNuYXBzaG90KCk6IGFueSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludGVybmFsU3RhdGVPcGVyYXRpb25zLmdldFJvb3RTdGF0ZU9wZXJhdGlvbnMoKS5nZXRTdGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSBzdGF0ZSB0byBhIHNwZWNpZmljIHBvaW50IGluIHRpbWUuIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bFxuICAgKiBmb3IgcGx1Z2luJ3Mgd2hvIG5lZWQgdG8gbW9kaWZ5IHRoZSBzdGF0ZSBkaXJlY3RseSBvciB1bml0IHRlc3RpbmcuXG4gICAqL1xuICByZXNldChzdGF0ZTogYW55KSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludGVybmFsU3RhdGVPcGVyYXRpb25zLmdldFJvb3RTdGF0ZU9wZXJhdGlvbnMoKS5zZXRTdGF0ZShzdGF0ZSk7XG4gIH1cblxuICBwcml2YXRlIGdldFN0b3JlQm91bmRTZWxlY3RvckZuKHNlbGVjdG9yOiBhbnkpIHtcbiAgICBjb25zdCBtYWtlU2VsZWN0b3JGbiA9IGdldFJvb3RTZWxlY3RvckZhY3Rvcnkoc2VsZWN0b3IpO1xuICAgIGNvbnN0IHJ1bnRpbWVDb250ZXh0ID0gdGhpcy5fc3RhdGVGYWN0b3J5LmdldFJ1bnRpbWVTZWxlY3RvckNvbnRleHQoKTtcbiAgICByZXR1cm4gbWFrZVNlbGVjdG9yRm4ocnVudGltZUNvbnRleHQpO1xuICB9XG5cbiAgcHJpdmF0ZSBpbml0U3RhdGVTdHJlYW0oaW5pdGlhbFN0YXRlVmFsdWU6IGFueSk6IHZvaWQge1xuICAgIGNvbnN0IHZhbHVlOiBQbGFpbk9iamVjdCA9IHRoaXMuX3N0YXRlU3RyZWFtLnZhbHVlO1xuICAgIGNvbnN0IHN0b3JlSXNFbXB0eTogYm9vbGVhbiA9ICF2YWx1ZSB8fCBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSAwO1xuICAgIGlmIChzdG9yZUlzRW1wdHkpIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRTdGF0ZU5vdEVtcHR5OiBib29sZWFuID0gT2JqZWN0LmtleXModGhpcy5fY29uZmlnLmRlZmF1bHRzU3RhdGUpLmxlbmd0aCA+IDA7XG4gICAgICBjb25zdCBzdG9yZVZhbHVlczogUGxhaW5PYmplY3QgPSBkZWZhdWx0U3RhdGVOb3RFbXB0eVxuICAgICAgICA/IHsgLi4udGhpcy5fY29uZmlnLmRlZmF1bHRzU3RhdGUsIC4uLmluaXRpYWxTdGF0ZVZhbHVlIH1cbiAgICAgICAgOiBpbml0aWFsU3RhdGVWYWx1ZTtcblxuICAgICAgdGhpcy5fc3RhdGVTdHJlYW0ubmV4dChzdG9yZVZhbHVlcyk7XG4gICAgfVxuICB9XG59XG4iXX0=