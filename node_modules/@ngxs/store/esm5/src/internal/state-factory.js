/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable, Injector, Optional, SkipSelf, Inject } from '@angular/core';
import { forkJoin, from, of, throwError, Subject, isObservable } from 'rxjs';
import { catchError, defaultIfEmpty, filter, map, mergeMap, shareReplay, takeUntil } from 'rxjs/operators';
import { INITIAL_STATE_TOKEN, memoize } from '@ngxs/store/internals';
import { META_KEY, NgxsConfig } from '../symbols';
import { buildGraph, findFullParentPath, isObject, nameToState, propGetter, topologicalSort, getStoreMetadata } from './internals';
import { getActionTypeFromInstance, getValue, setValue } from '../utils/utils';
import { ofActionDispatched } from '../operators/of-action';
import { InternalActions } from '../actions-stream';
import { InternalDispatchedActionResults } from '../internal/dispatcher';
import { StateContextFactory } from '../internal/state-context-factory';
import { StoreValidators } from '../utils/store-validators';
import { ensureStateClassIsInjectable } from '../ivy/ivy-enabled-in-dev-mode';
/**
 * State factory class
 * @ignore
 */
var StateFactory = /** @class */ (function () {
    function StateFactory(_injector, _config, _parentFactory, _actions, _actionResults, _stateContextFactory, _initialState) {
        var _this = this;
        this._injector = _injector;
        this._config = _config;
        this._parentFactory = _parentFactory;
        this._actions = _actions;
        this._actionResults = _actionResults;
        this._stateContextFactory = _stateContextFactory;
        this._initialState = _initialState;
        this._actionsSubscription = null;
        this._states = [];
        this._statesByName = {};
        this._statePaths = {};
        this.getRuntimeSelectorContext = memoize((/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var stateFactory = _this;
            /**
             * @param {?} key
             * @return {?}
             */
            function resolveGetter(key) {
                /** @type {?} */
                var path = stateFactory.statePaths[key];
                return path ? propGetter(path.split('.'), stateFactory._config) : null;
            }
            /** @type {?} */
            var context = _this._parentFactory
                ? _this._parentFactory.getRuntimeSelectorContext()
                : {
                    getStateGetter: /**
                     * @param {?} key
                     * @return {?}
                     */
                    function (key) {
                        /** @type {?} */
                        var getter = resolveGetter(key);
                        if (getter) {
                            return getter;
                        }
                        return (/**
                         * @param {...?} args
                         * @return {?}
                         */
                        function () {
                            var args = [];
                            for (var _i = 0; _i < arguments.length; _i++) {
                                args[_i] = arguments[_i];
                            }
                            // Late loaded getter
                            if (!getter) {
                                getter = resolveGetter(key);
                            }
                            return getter ? getter.apply(void 0, tslib_1.__spread(args)) : undefined;
                        });
                    },
                    getSelectorOptions: /**
                     * @param {?=} localOptions
                     * @return {?}
                     */
                    function (localOptions) {
                        /** @type {?} */
                        var globalSelectorOptions = stateFactory._config.selectorOptions;
                        return tslib_1.__assign({}, globalSelectorOptions, (localOptions || {}));
                    }
                };
            return context;
        }));
    }
    Object.defineProperty(StateFactory.prototype, "states", {
        get: /**
         * @return {?}
         */
        function () {
            return this._parentFactory ? this._parentFactory.states : this._states;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateFactory.prototype, "statesByName", {
        get: /**
         * @return {?}
         */
        function () {
            return this._parentFactory ? this._parentFactory.statesByName : this._statesByName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateFactory.prototype, "statePaths", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return this._parentFactory ? this._parentFactory.statePaths : this._statePaths;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @param {?} defaults
     * @return {?}
     */
    StateFactory.cloneDefaults = /**
     * @private
     * @param {?} defaults
     * @return {?}
     */
    function (defaults) {
        /** @type {?} */
        var value = {};
        if (Array.isArray(defaults)) {
            value = defaults.slice();
        }
        else if (isObject(defaults)) {
            value = tslib_1.__assign({}, defaults);
        }
        else if (defaults === undefined) {
            value = {};
        }
        else {
            value = defaults;
        }
        return value;
    };
    /**
     * @return {?}
     */
    StateFactory.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        // I'm using non-null assertion here since `_actionsSubscrition` will
        // be 100% defined. This is because `ngOnDestroy()` cannot be invoked
        // on the `StateFactory` until its initialized :) An it's initialized
        // for the first time along with the `NgxsRootModule`.
        (/** @type {?} */ (this._actionsSubscription)).unsubscribe();
    };
    /**
     * Add a new state to the global defs.
     */
    /**
     * Add a new state to the global defs.
     * @param {?} stateClasses
     * @return {?}
     */
    StateFactory.prototype.add = /**
     * Add a new state to the global defs.
     * @param {?} stateClasses
     * @return {?}
     */
    function (stateClasses) {
        var e_1, _a;
        // Caretaker note: we have still left the `typeof` condition in order to avoid
        // creating a breaking change for projects that still use the View Engine.
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
            StoreValidators.checkThatStateClassesHaveBeenDecorated(stateClasses);
        }
        var newStates = this.addToStatesMap(stateClasses).newStates;
        if (!newStates.length)
            return [];
        /** @type {?} */
        var stateGraph = buildGraph(newStates);
        /** @type {?} */
        var sortedStates = topologicalSort(stateGraph);
        /** @type {?} */
        var paths = findFullParentPath(stateGraph);
        /** @type {?} */
        var nameGraph = nameToState(newStates);
        /** @type {?} */
        var bootstrappedStores = [];
        try {
            for (var sortedStates_1 = tslib_1.__values(sortedStates), sortedStates_1_1 = sortedStates_1.next(); !sortedStates_1_1.done; sortedStates_1_1 = sortedStates_1.next()) {
                var name_1 = sortedStates_1_1.value;
                /** @type {?} */
                var stateClass = nameGraph[name_1];
                /** @type {?} */
                var path = paths[name_1];
                /** @type {?} */
                var meta = (/** @type {?} */ (stateClass[META_KEY]));
                this.addRuntimeInfoToMeta(meta, path);
                // Note: previously we called `ensureStateClassIsInjectable` within the
                // `State` decorator. This check is moved here because the `Éµprov` property
                // will not exist on the class in JIT mode (because it's set asynchronously
                // during JIT compilation through `Object.defineProperty`).
                if (typeof ngDevMode === 'undefined' || ngDevMode) {
                    ensureStateClassIsInjectable(stateClass);
                }
                /** @type {?} */
                var stateMap = {
                    name: name_1,
                    path: path,
                    isInitialised: false,
                    actions: meta.actions,
                    instance: this._injector.get(stateClass),
                    defaults: StateFactory.cloneDefaults(meta.defaults)
                };
                // ensure our store hasn't already been added
                // but don't throw since it could be lazy
                // loaded from different paths
                if (!this.hasBeenMountedAndBootstrapped(name_1, path)) {
                    bootstrappedStores.push(stateMap);
                }
                this.states.push(stateMap);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (sortedStates_1_1 && !sortedStates_1_1.done && (_a = sortedStates_1.return)) _a.call(sortedStates_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return bootstrappedStores;
    };
    /**
     * Add a set of states to the store and return the defaults
     */
    /**
     * Add a set of states to the store and return the defaults
     * @param {?} stateClasses
     * @return {?}
     */
    StateFactory.prototype.addAndReturnDefaults = /**
     * Add a set of states to the store and return the defaults
     * @param {?} stateClasses
     * @return {?}
     */
    function (stateClasses) {
        /** @type {?} */
        var classes = stateClasses || [];
        /** @type {?} */
        var mappedStores = this.add(classes);
        /** @type {?} */
        var defaults = mappedStores.reduce((/**
         * @param {?} result
         * @param {?} mappedStore
         * @return {?}
         */
        function (result, mappedStore) {
            return setValue(result, mappedStore.path, mappedStore.defaults);
        }), {});
        return { defaults: defaults, states: mappedStores };
    };
    /**
     * Bind the actions to the handlers
     */
    /**
     * Bind the actions to the handlers
     * @return {?}
     */
    StateFactory.prototype.connectActionHandlers = /**
     * Bind the actions to the handlers
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._actionsSubscription !== null)
            return;
        /** @type {?} */
        var dispatched$ = new Subject();
        this._actionsSubscription = this._actions
            .pipe(filter((/**
         * @param {?} ctx
         * @return {?}
         */
        function (ctx) { return ctx.status === "DISPATCHED" /* Dispatched */; })), mergeMap((/**
         * @param {?} ctx
         * @return {?}
         */
        function (ctx) {
            dispatched$.next(ctx);
            /** @type {?} */
            var action = ctx.action;
            return _this.invokeActions(dispatched$, (/** @type {?} */ (action))).pipe(map((/**
             * @return {?}
             */
            function () { return (/** @type {?} */ ({ action: action, status: "SUCCESSFUL" /* Successful */ })); })), defaultIfEmpty((/** @type {?} */ ({ action: action, status: "CANCELED" /* Canceled */ }))), catchError((/**
             * @param {?} error
             * @return {?}
             */
            function (error) {
                return of((/** @type {?} */ ({ action: action, status: "ERRORED" /* Errored */, error: error })));
            })));
        })))
            .subscribe((/**
         * @param {?} ctx
         * @return {?}
         */
        function (ctx) { return _this._actionResults.next(ctx); }));
    };
    /**
     * Invoke actions on the states.
     */
    /**
     * Invoke actions on the states.
     * @param {?} dispatched$
     * @param {?} action
     * @return {?}
     */
    StateFactory.prototype.invokeActions = /**
     * Invoke actions on the states.
     * @param {?} dispatched$
     * @param {?} action
     * @return {?}
     */
    function (dispatched$, action) {
        var e_2, _a, e_3, _b;
        /** @type {?} */
        var type = (/** @type {?} */ (getActionTypeFromInstance(action)));
        /** @type {?} */
        var results = [];
        try {
            for (var _c = tslib_1.__values(this.states), _d = _c.next(); !_d.done; _d = _c.next()) {
                var metadata = _d.value;
                /** @type {?} */
                var actionMetas = metadata.actions[type];
                if (actionMetas) {
                    try {
                        for (var actionMetas_1 = tslib_1.__values(actionMetas), actionMetas_1_1 = actionMetas_1.next(); !actionMetas_1_1.done; actionMetas_1_1 = actionMetas_1.next()) {
                            var actionMeta = actionMetas_1_1.value;
                            /** @type {?} */
                            var stateContext = this._stateContextFactory.createStateContext(metadata);
                            try {
                                /** @type {?} */
                                var result = metadata.instance[actionMeta.fn](stateContext, action);
                                if (result instanceof Promise) {
                                    result = from(result);
                                }
                                if (isObservable(result)) {
                                    // If this observable has been completed w/o emitting
                                    // any value then we wouldn't want to complete the whole chain
                                    // of actions. Since if any observable completes then
                                    // action will be canceled.
                                    // For instance if any action handler would've had such statement:
                                    // `handler(ctx) { return EMPTY; }`
                                    // then the action will be canceled.
                                    // See https://github.com/ngxs/store/issues/1568
                                    result = result.pipe(mergeMap((/**
                                     * @param {?} value
                                     * @return {?}
                                     */
                                    function (value) {
                                        if (value instanceof Promise) {
                                            return from(value);
                                        }
                                        if (isObservable(value)) {
                                            return value;
                                        }
                                        return of(value);
                                    })), defaultIfEmpty({}));
                                    if (actionMeta.options.cancelUncompleted) {
                                        // todo: ofActionDispatched should be used with action class
                                        result = result.pipe(takeUntil(dispatched$.pipe(ofActionDispatched((/** @type {?} */ (action))))));
                                    }
                                }
                                else {
                                    result = of({}).pipe(shareReplay());
                                }
                                results.push(result);
                            }
                            catch (e) {
                                results.push(throwError(e));
                            }
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (actionMetas_1_1 && !actionMetas_1_1.done && (_b = actionMetas_1.return)) _b.call(actionMetas_1);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_2) throw e_2.error; }
        }
        if (!results.length) {
            results.push(of({}));
        }
        return forkJoin(results);
    };
    /**
     * @private
     * @param {?} stateClasses
     * @return {?}
     */
    StateFactory.prototype.addToStatesMap = /**
     * @private
     * @param {?} stateClasses
     * @return {?}
     */
    function (stateClasses) {
        var e_4, _a;
        /** @type {?} */
        var newStates = [];
        /** @type {?} */
        var statesMap = this.statesByName;
        try {
            for (var stateClasses_1 = tslib_1.__values(stateClasses), stateClasses_1_1 = stateClasses_1.next(); !stateClasses_1_1.done; stateClasses_1_1 = stateClasses_1.next()) {
                var stateClass = stateClasses_1_1.value;
                /** @type {?} */
                var stateName = (/** @type {?} */ (getStoreMetadata(stateClass).name));
                // Caretaker note: we have still left the `typeof` condition in order to avoid
                // creating a breaking change for projects that still use the View Engine.
                if (typeof ngDevMode === 'undefined' || ngDevMode) {
                    StoreValidators.checkThatStateNameIsUnique(stateName, stateClass, statesMap);
                }
                /** @type {?} */
                var unmountedState = !statesMap[stateName];
                if (unmountedState) {
                    newStates.push(stateClass);
                    statesMap[stateName] = stateClass;
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (stateClasses_1_1 && !stateClasses_1_1.done && (_a = stateClasses_1.return)) _a.call(stateClasses_1);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return { newStates: newStates };
    };
    /**
     * @private
     * @param {?} meta
     * @param {?} path
     * @return {?}
     */
    StateFactory.prototype.addRuntimeInfoToMeta = /**
     * @private
     * @param {?} meta
     * @param {?} path
     * @return {?}
     */
    function (meta, path) {
        this.statePaths[(/** @type {?} */ (meta.name))] = path;
        // TODO: v4 - we plan to get rid of the path property because it is non-deterministic
        // we can do this when we get rid of the incorrectly exposed getStoreMetadata
        // We will need to come up with an alternative in v4 because this is used by many plugins
        meta.path = path;
    };
    /**
     * @description
     * the method checks if the state has already been added to the tree
     * and completed the life cycle
     * @param name
     * @param path
     */
    /**
     * \@description
     * the method checks if the state has already been added to the tree
     * and completed the life cycle
     * @private
     * @param {?} name
     * @param {?} path
     * @return {?}
     */
    StateFactory.prototype.hasBeenMountedAndBootstrapped = /**
     * \@description
     * the method checks if the state has already been added to the tree
     * and completed the life cycle
     * @private
     * @param {?} name
     * @param {?} path
     * @return {?}
     */
    function (name, path) {
        /** @type {?} */
        var valueIsBootstrappedInInitialState = getValue(this._initialState, path) !== undefined;
        return this.statesByName[name] && valueIsBootstrappedInInitialState;
    };
    StateFactory.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    StateFactory.ctorParameters = function () { return [
        { type: Injector },
        { type: NgxsConfig },
        { type: StateFactory, decorators: [{ type: Optional }, { type: SkipSelf }] },
        { type: InternalActions },
        { type: InternalDispatchedActionResults },
        { type: StateContextFactory },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [INITIAL_STATE_TOKEN,] }] }
    ]; };
    return StateFactory;
}());
export { StateFactory };
if (false) {
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._actionsSubscription;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._states;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._statesByName;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._statePaths;
    /** @type {?} */
    StateFactory.prototype.getRuntimeSelectorContext;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._injector;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._config;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._parentFactory;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._actions;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._actionResults;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._stateContextFactory;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._initialState;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGUtZmFjdG9yeS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuZ3hzL3N0b3JlLyIsInNvdXJjZXMiOlsic3JjL2ludGVybmFsL3N0YXRlLWZhY3RvcnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBYSxNQUFNLGVBQWUsQ0FBQztBQUM1RixPQUFPLEVBQ0wsUUFBUSxFQUNSLElBQUksRUFFSixFQUFFLEVBQ0YsVUFBVSxFQUVWLE9BQU8sRUFDUCxZQUFZLEVBQ2IsTUFBTSxNQUFNLENBQUM7QUFDZCxPQUFPLEVBQ0wsVUFBVSxFQUNWLGNBQWMsRUFDZCxNQUFNLEVBQ04sR0FBRyxFQUNILFFBQVEsRUFDUixXQUFXLEVBQ1gsU0FBUyxFQUNWLE1BQU0sZ0JBQWdCLENBQUM7QUFDeEIsT0FBTyxFQUFFLG1CQUFtQixFQUFpQixPQUFPLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUVwRixPQUFPLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxNQUFNLFlBQVksQ0FBQztBQUNsRCxPQUFPLEVBQ0wsVUFBVSxFQUNWLGtCQUFrQixFQUNsQixRQUFRLEVBR1IsV0FBVyxFQUNYLFVBQVUsRUFLVixlQUFlLEVBR2YsZ0JBQWdCLEVBQ2pCLE1BQU0sYUFBYSxDQUFDO0FBQ3JCLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDL0UsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDNUQsT0FBTyxFQUErQixlQUFlLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNqRixPQUFPLEVBQUUsK0JBQStCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUN6RSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxtQ0FBbUMsQ0FBQztBQUN4RSxPQUFPLEVBQUUsZUFBZSxFQUFF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NkU7UUFDN0UseUZBQXlGO1FBQ3pGLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0lBQ25CLENBQUM7SUFFRDs7Ozs7O09BTUc7Ozs7Ozs7Ozs7SUFDSyxvREFBNkI7Ozs7Ozs7OztJQUFyQyxVQUFzQyxJQUFZLEVBQUUsSUFBWTs7WUFDeEQsaUNBQWlDLEdBQ3JDLFFBQVEsQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQyxLQUFLLFNBQVM7UUFDbEQsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLGlDQUFpQyxDQUFDO0lBQ3RFLENBQUM7O2dCQTNTRixVQUFVOzs7O2dCQXBEVSxRQUFRO2dCQXNCVixVQUFVO2dCQXVDRCxZQUFZLHVCQUZuQyxRQUFRLFlBQ1IsUUFBUTtnQkFsQnlCLGVBQWU7Z0JBQzVDLCtCQUErQjtnQkFDL0IsbUJBQW1CO2dEQXFCdkIsUUFBUSxZQUNSLE1BQU0sU0FBQyxtQkFBbUI7O0lBOFIvQixtQkFBQztDQUFBLEFBNVNELElBNFNDO1NBM1NZLFlBQVk7Ozs7OztJQUN2Qiw0Q0FBeUQ7Ozs7O0lBZ0J6RCwrQkFBb0M7Ozs7O0lBTXBDLHFDQUF5Qzs7Ozs7SUFNekMsbUNBQWdEOztJQU1oRCxpREFpQ0c7Ozs7O0lBaEVELGlDQUEyQjs7Ozs7SUFDM0IsK0JBQTJCOzs7OztJQUMzQixzQ0FFb0M7Ozs7O0lBQ3BDLGdDQUFpQzs7Ozs7SUFDakMsc0NBQXVEOzs7OztJQUN2RCw0Q0FBaUQ7Ozs7O0lBQ2pELHFDQUUwQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIEluamVjdG9yLCBPcHRpb25hbCwgU2tpcFNlbGYsIEluamVjdCwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBmb3JrSm9pbixcbiAgZnJvbSxcbiAgT2JzZXJ2YWJsZSxcbiAgb2YsXG4gIHRocm93RXJyb3IsXG4gIFN1YnNjcmlwdGlvbixcbiAgU3ViamVjdCxcbiAgaXNPYnNlcnZhYmxlXG59IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtcbiAgY2F0Y2hFcnJvcixcbiAgZGVmYXVsdElmRW1wdHksXG4gIGZpbHRlcixcbiAgbWFwLFxuICBtZXJnZU1hcCxcbiAgc2hhcmVSZXBsYXksXG4gIHRha2VVbnRpbFxufSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBJTklUSUFMX1NUQVRFX1RPS0VOLCBQbGFpbk9iamVjdE9mLCBtZW1vaXplIH0gZnJvbSAnQG5neHMvc3RvcmUvaW50ZXJuYWxzJztcblxuaW1wb3J0IHsgTUVUQV9LRVksIE5neHNDb25maWcgfSBmcm9tICcuLi9zeW1ib2xzJztcbmltcG9ydCB7XG4gIGJ1aWxkR3JhcGgsXG4gIGZpbmRGdWxsUGFyZW50UGF0aCxcbiAgaXNPYmplY3QsXG4gIE1hcHBlZFN0b3JlLFxuICBNZXRhRGF0YU1vZGVsLFxuICBuYW1lVG9TdGF0ZSxcbiAgcHJvcEdldHRlcixcbiAgU3RhdGVDbGFzc0ludGVybmFsLFxuICBTdGF0ZUtleUdyYXBoLFxuICBTdGF0ZXNBbmREZWZhdWx0cyxcbiAgU3RhdGVzQnlOYW1lLFxuICB0b3BvbG9naWNhbFNvcnQsXG4gIFJ1bnRpbWVTZWxlY3RvckNvbnRleHQsXG4gIFNoYXJlZFNlbGVjdG9yT3B0aW9ucyxcbiAgZ2V0U3RvcmVNZXRhZGF0YVxufSBmcm9tICcuL2ludGVybmFscyc7XG5pbXBvcnQgeyBnZXRBY3Rpb25UeXBlRnJvbUluc3RhbmNlLCBnZXRWYWx1ZSwgc2V0VmFsdWUgfSBmcm9tICcuLi91dGlscy91dGlscyc7XG5pbXBvcnQgeyBvZkFjdGlvbkRpc3BhdGNoZWQgfSBmcm9tICcuLi9vcGVyYXRvcnMvb2YtYWN0aW9uJztcbmltcG9ydCB7IEFjdGlvbkNvbnRleHQsIEFjdGlvblN0YXR1cywgSW50ZXJuYWxBY3Rpb25zIH0gZnJvbSAnLi4vYWN0aW9ucy1zdHJlYW0nO1xuaW1wb3J0IHsgSW50ZXJuYWxEaXNwYXRjaGVkQWN0aW9uUmVzdWx0cyB9IGZyb20gJy4uL2ludGVybmFsL2Rpc3BhdGNoZXInO1xuaW1wb3J0IHsgU3RhdGVDb250ZXh0RmFjdG9yeSB9IGZyb20gJy4uL2ludGVybmFsL3N0YXRlLWNvbnRleHQtZmFjdG9yeSc7XG5pbXBvcnQgeyBTdG9yZVZhbGlkYXRvcnMgfSBmcm9tICcuLi91dGlscy9zdG9yZS12YWxpZGF0b3JzJztcbmltcG9ydCB7IGVuc3VyZVN0YXRlQ2xhc3NJc0luamVjdGFibGUgfSBmcm9tICcuLi9pdnkvaXZ5LWVuYWJsZWQtaW4tZGV2LW1vZGUnO1xuXG4vKipcbiAqIFN0YXRlIGZhY3RvcnkgY2xhc3NcbiAqIEBpZ25vcmVcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFN0YXRlRmFjdG9yeSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgX2FjdGlvbnNTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbiB8IG51bGwgPSBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgX2luamVjdG9yOiBJbmplY3RvcixcbiAgICBwcml2YXRlIF9jb25maWc6IE5neHNDb25maWcsXG4gICAgQE9wdGlvbmFsKClcbiAgICBAU2tpcFNlbGYoKVxuICAgIHByaXZhdGUgX3BhcmVudEZhY3Rvcnk6IFN0YXRlRmFjdG9yeSxcbiAgICBwcml2YXRlIF9hY3Rpb25zOiBJbnRlcm5hbEFjdGlvbnMsXG4gICAgcHJpdmF0ZSBfYWN0aW9uUmVzdWx0czogSW50ZXJuYWxEaXNwYXRjaGVkQWN0aW9uUmVzdWx0cyxcbiAgICBwcml2YXRlIF9zdGF0ZUNvbnRleHRGYWN0b3J5OiBTdGF0ZUNvbnRleHRGYWN0b3J5LFxuICAgIEBPcHRpb25hbCgpXG4gICAgQEluamVjdChJTklUSUFMX1NUQVRFX1RPS0VOKVxuICAgIHByaXZhdGUgX2luaXRpYWxTdGF0ZTogYW55XG4gICkge31cblxuICBwcml2YXRlIF9zdGF0ZXM6IE1hcHBlZFN0b3JlW10gPSBbXTtcblxuICBnZXQgc3RhdGVzKCk6IE1hcHBlZFN0b3JlW10ge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnRGYWN0b3J5ID8gdGhpcy5fcGFyZW50RmFjdG9yeS5zdGF0ZXMgOiB0aGlzLl9zdGF0ZXM7XG4gIH1cblxuICBwcml2YXRlIF9zdGF0ZXNCeU5hbWU6IFN0YXRlc0J5TmFtZSA9IHt9O1xuXG4gIGdldCBzdGF0ZXNCeU5hbWUoKTogU3RhdGVzQnlOYW1lIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50RmFjdG9yeSA/IHRoaXMuX3BhcmVudEZhY3Rvcnkuc3RhdGVzQnlOYW1lIDogdGhpcy5fc3RhdGVzQnlOYW1lO1xuICB9XG5cbiAgcHJpdmF0ZSBfc3RhdGVQYXRoczogUGxhaW5PYmplY3RPZjxzdHJpbmc+ID0ge307XG5cbiAgcHJpdmF0ZSBnZXQgc3RhdGVQYXRocygpOiBQbGFpbk9iamVjdE9mPHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnRGYWN0b3J5ID8gdGhpcy5fcGFyZW50RmFjdG9yeS5zdGF0ZVBhdGhzIDogdGhpcy5fc3RhdGVQYXRocztcbiAgfVxuXG4gIGdldFJ1bnRpbWVTZWxlY3RvckNvbnRleHQgPSBtZW1vaXplKCgpID0+IHtcbiAgICBjb25zdCBzdGF0ZUZhY3RvcnkgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZUdldHRlcihrZXk6IHN0cmluZykge1xuICAgICAgY29uc3QgcGF0aCA9IHN0YXRlRmFjdG9yeS5zdGF0ZVBhdGhzW2tleV07XG4gICAgICByZXR1cm4gcGF0aCA/IHByb3BHZXR0ZXIocGF0aC5zcGxpdCgnLicpLCBzdGF0ZUZhY3RvcnkuX2NvbmZpZykgOiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnRleHQ6IFJ1bnRpbWVTZWxlY3RvckNvbnRleHQgPSB0aGlzLl9wYXJlbnRGYWN0b3J5XG4gICAgICA/IHRoaXMuX3BhcmVudEZhY3RvcnkuZ2V0UnVudGltZVNlbGVjdG9yQ29udGV4dCgpXG4gICAgICA6IHtcbiAgICAgICAgICBnZXRTdGF0ZUdldHRlcihrZXk6IHN0cmluZykge1xuICAgICAgICAgICAgbGV0IGdldHRlciA9IHJlc29sdmVHZXR0ZXIoa2V5KTtcbiAgICAgICAgICAgIGlmIChnZXR0ZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldHRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAvLyBMYXRlIGxvYWRlZCBnZXR0ZXJcbiAgICAgICAgICAgICAgaWYgKCFnZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICBnZXR0ZXIgPSByZXNvbHZlR2V0dGVyKGtleSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGdldHRlciA/IGdldHRlciguLi5hcmdzKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXRTZWxlY3Rvck9wdGlvbnMobG9jYWxPcHRpb25zPzogU2hhcmVkU2VsZWN0b3JPcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBnbG9iYWxTZWxlY3Rvck9wdGlvbnMgPSBzdGF0ZUZhY3RvcnkuX2NvbmZpZy5zZWxlY3Rvck9wdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi5nbG9iYWxTZWxlY3Rvck9wdGlvbnMsXG4gICAgICAgICAgICAgIC4uLihsb2NhbE9wdGlvbnMgfHwge30pXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICByZXR1cm4gY29udGV4dDtcbiAgfSk7XG5cbiAgcHJpdmF0ZSBzdGF0aWMgY2xvbmVEZWZhdWx0cyhkZWZhdWx0czogYW55KTogYW55IHtcbiAgICBsZXQgdmFsdWUgPSB7fTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGRlZmF1bHRzKSkge1xuICAgICAgdmFsdWUgPSBkZWZhdWx0cy5zbGljZSgpO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoZGVmYXVsdHMpKSB7XG4gICAgICB2YWx1ZSA9IHsgLi4uZGVmYXVsdHMgfTtcbiAgICB9IGVsc2UgaWYgKGRlZmF1bHRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbHVlID0ge307XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gZGVmYXVsdHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgLy8gSSdtIHVzaW5nIG5vbi1udWxsIGFzc2VydGlvbiBoZXJlIHNpbmNlIGBfYWN0aW9uc1N1YnNjcml0aW9uYCB3aWxsXG4gICAgLy8gYmUgMTAwJSBkZWZpbmVkLiBUaGlzIGlzIGJlY2F1c2UgYG5nT25EZXN0cm95KClgIGNhbm5vdCBiZSBpbnZva2VkXG4gICAgLy8gb24gdGhlIGBTdGF0ZUZhY3RvcnlgIHVudGlsIGl0cyBpbml0aWFsaXplZCA6KSBBbiBpdCdzIGluaXRpYWxpemVkXG4gICAgLy8gZm9yIHRoZSBmaXJzdCB0aW1lIGFsb25nIHdpdGggdGhlIGBOZ3hzUm9vdE1vZHVsZWAuXG4gICAgdGhpcy5fYWN0aW9uc1N1YnNjcmlwdGlvbiEudW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgc3RhdGUgdG8gdGhlIGdsb2JhbCBkZWZzLlxuICAgKi9cbiAgYWRkKHN0YXRlQ2xhc3NlczogU3RhdGVDbGFzc0ludGVybmFsW10pOiBNYXBwZWRTdG9yZVtdIHtcbiAgICAvLyBDYXJldGFrZXIgbm90ZTogd2UgaGF2ZSBzdGlsbCBsZWZ0IHRoZSBgdHlwZW9mYCBjb25kaXRpb24gaW4gb3JkZXIgdG8gYXZvaWRcbiAgICAvLyBjcmVhdGluZyBhIGJyZWFraW5nIGNoYW5nZSBmb3IgcHJvamVjdHMgdGhhdCBzdGlsbCB1c2UgdGhlIFZpZXcgRW5naW5lLlxuICAgIGlmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpIHtcbiAgICAgIFN0b3JlVmFsaWRhdG9ycy5jaGVja1RoYXRTdGF0ZUNsYXNzZXNIYXZlQmVlbkRlY29yYXRlZChzdGF0ZUNsYXNzZXMpO1xuICAgIH1cblxuICAgIGNvbnN0IHsgbmV3U3RhdGVzIH0gPSB0aGlzLmFkZFRvU3RhdGVzTWFwKHN0YXRlQ2xhc3Nlcyk7XG4gICAgaWYgKCFuZXdTdGF0ZXMubGVuZ3RoKSByZXR1cm4gW107XG5cbiAgICBjb25zdCBzdGF0ZUdyYXBoOiBTdGF0ZUtleUdyYXBoID0gYnVpbGRHcmFwaChuZXdTdGF0ZXMpO1xuICAgIGNvbnN0IHNvcnRlZFN0YXRlczogc3RyaW5nW10gPSB0b3BvbG9naWNhbFNvcnQoc3RhdGVHcmFwaCk7XG4gICAgY29uc3QgcGF0aHM6IFBsYWluT2JqZWN0T2Y8c3RyaW5nPiA9IGZpbmRGdWxsUGFyZW50UGF0aChzdGF0ZUdyYXBoKTtcbiAgICBjb25zdCBuYW1lR3JhcGg6IFBsYWluT2JqZWN0T2Y8U3RhdGVDbGFzc0ludGVybmFsPiA9IG5hbWVUb1N0YXRlKG5ld1N0YXRlcyk7XG4gICAgY29uc3QgYm9vdHN0cmFwcGVkU3RvcmVzOiBNYXBwZWRTdG9yZVtdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygc29ydGVkU3RhdGVzKSB7XG4gICAgICBjb25zdCBzdGF0ZUNsYXNzOiBTdGF0ZUNsYXNzSW50ZXJuYWwgPSBuYW1lR3JhcGhbbmFtZV07XG4gICAgICBjb25zdCBwYXRoOiBzdHJpbmcgPSBwYXRoc1tuYW1lXTtcbiAgICAgIGNvbnN0IG1ldGE6IE1ldGFEYXRhTW9kZWwgPSBzdGF0ZUNsYXNzW01FVEFfS0VZXSE7XG5cbiAgICAgIHRoaXMuYWRkUnVudGltZUluZm9Ub01ldGEobWV0YSwgcGF0aCk7XG5cbiAgICAgIC8vIE5vdGU6IHByZXZpb3VzbHkgd2UgY2FsbGVkIGBlbnN1cmVTdGF0ZUNsYXNzSXNJbmplY3RhYmxlYCB3aXRoaW4gdGhlXG4gICAgICAvLyBgU3RhdGVgIGRlY29yYXRvci4gVGhpcyBjaGVjayBpcyBtb3ZlZCBoZXJlIGJlY2F1c2UgdGhlIGDJtXByb3ZgIHByb3BlcnR5XG4gICAgICAvLyB3aWxsIG5vdCBleGlzdCBvbiB0aGUgY2xhc3MgaW4gSklUIG1vZGUgKGJlY2F1c2UgaXQncyBzZXQgYXN5bmNocm9ub3VzbHlcbiAgICAgIC8vIGR1cmluZyBKSVQgY29tcGlsYXRpb24gdGhyb3VnaCBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCkuXG4gICAgICBpZiAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSB7XG4gICAgICAgIGVuc3VyZVN0YXRlQ2xhc3NJc0luamVjdGFibGUoc3RhdGVDbGFzcyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN0YXRlTWFwOiBNYXBwZWRTdG9yZSA9IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgaXNJbml0aWFsaXNlZDogZmFsc2UsXG4gICAgICAgIGFjdGlvbnM6IG1ldGEuYWN0aW9ucyxcbiAgICAgICAgaW5zdGFuY2U6IHRoaXMuX2luamVjdG9yLmdldChzdGF0ZUNsYXNzKSxcbiAgICAgICAgZGVmYXVsdHM6IFN0YXRlRmFjdG9yeS5jbG9uZURlZmF1bHRzKG1ldGEuZGVmYXVsdHMpXG4gICAgICB9O1xuXG4gICAgICAvLyBlbnN1cmUgb3VyIHN0b3JlIGhhc24ndCBhbHJlYWR5IGJlZW4gYWRkZWRcbiAgICAgIC8vIGJ1dCBkb24ndCB0aHJvdyBzaW5jZSBpdCBjb3VsZCBiZSBsYXp5XG4gICAgICAvLyBsb2FkZWQgZnJvbSBkaWZmZXJlbnQgcGF0aHNcbiAgICAgIGlmICghdGhpcy5oYXNCZWVuTW91bnRlZEFuZEJvb3RzdHJhcHBlZChuYW1lLCBwYXRoKSkge1xuICAgICAgICBib290c3RyYXBwZWRTdG9yZXMucHVzaChzdGF0ZU1hcCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhdGVzLnB1c2goc3RhdGVNYXApO1xuICAgIH1cblxuICAgIHJldHVybiBib290c3RyYXBwZWRTdG9yZXM7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgc2V0IG9mIHN0YXRlcyB0byB0aGUgc3RvcmUgYW5kIHJldHVybiB0aGUgZGVmYXVsdHNcbiAgICovXG4gIGFkZEFuZFJldHVybkRlZmF1bHRzKHN0YXRlQ2xhc3NlczogU3RhdGVDbGFzc0ludGVybmFsW10pOiBTdGF0ZXNBbmREZWZhdWx0cyB7XG4gICAgY29uc3QgY2xhc3NlczogU3RhdGVDbGFzc0ludGVybmFsW10gPSBzdGF0ZUNsYXNzZXMgfHwgW107XG5cbiAgICBjb25zdCBtYXBwZWRTdG9yZXM6IE1hcHBlZFN0b3JlW10gPSB0aGlzLmFkZChjbGFzc2VzKTtcbiAgICBjb25zdCBkZWZhdWx0cyA9IG1hcHBlZFN0b3Jlcy5yZWR1Y2UoXG4gICAgICAocmVzdWx0OiBhbnksIG1hcHBlZFN0b3JlOiBNYXBwZWRTdG9yZSkgPT5cbiAgICAgICAgc2V0VmFsdWUocmVzdWx0LCBtYXBwZWRTdG9yZS5wYXRoLCBtYXBwZWRTdG9yZS5kZWZhdWx0cyksXG4gICAgICB7fVxuICAgICk7XG4gICAgcmV0dXJuIHsgZGVmYXVsdHMsIHN0YXRlczogbWFwcGVkU3RvcmVzIH07XG4gIH1cblxuICAvKipcbiAgICogQmluZCB0aGUgYWN0aW9ucyB0byB0aGUgaGFuZGxlcnNcbiAgICovXG4gIGNvbm5lY3RBY3Rpb25IYW5kbGVycygpIHtcbiAgICBpZiAodGhpcy5fYWN0aW9uc1N1YnNjcmlwdGlvbiAhPT0gbnVsbCkgcmV0dXJuO1xuICAgIGNvbnN0IGRpc3BhdGNoZWQkID0gbmV3IFN1YmplY3Q8QWN0aW9uQ29udGV4dD4oKTtcbiAgICB0aGlzLl9hY3Rpb25zU3Vic2NyaXB0aW9uID0gdGhpcy5fYWN0aW9uc1xuICAgICAgLnBpcGUoXG4gICAgICAgIGZpbHRlcigoY3R4OiBBY3Rpb25Db250ZXh0KSA9PiBjdHguc3RhdHVzID09PSBBY3Rpb25TdGF0dXMuRGlzcGF0Y2hlZCksXG4gICAgICAgIG1lcmdlTWFwKGN0eCA9PiB7XG4gICAgICAgICAgZGlzcGF0Y2hlZCQubmV4dChjdHgpO1xuICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IGN0eC5hY3Rpb247XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaW52b2tlQWN0aW9ucyhkaXNwYXRjaGVkJCwgYWN0aW9uISkucGlwZShcbiAgICAgICAgICAgIG1hcCgoKSA9PiA8QWN0aW9uQ29udGV4dD57IGFjdGlvbiwgc3RhdHVzOiBBY3Rpb25TdGF0dXMuU3VjY2Vzc2Z1bCB9KSxcbiAgICAgICAgICAgIGRlZmF1bHRJZkVtcHR5KDxBY3Rpb25Db250ZXh0PnsgYWN0aW9uLCBzdGF0dXM6IEFjdGlvblN0YXR1cy5DYW5jZWxlZCB9KSxcbiAgICAgICAgICAgIGNhdGNoRXJyb3IoZXJyb3IgPT5cbiAgICAgICAgICAgICAgb2YoPEFjdGlvbkNvbnRleHQ+eyBhY3Rpb24sIHN0YXR1czogQWN0aW9uU3RhdHVzLkVycm9yZWQsIGVycm9yIH0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUoY3R4ID0+IHRoaXMuX2FjdGlvblJlc3VsdHMubmV4dChjdHgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2UgYWN0aW9ucyBvbiB0aGUgc3RhdGVzLlxuICAgKi9cbiAgaW52b2tlQWN0aW9ucyhkaXNwYXRjaGVkJDogT2JzZXJ2YWJsZTxBY3Rpb25Db250ZXh0PiwgYWN0aW9uOiBhbnkpIHtcbiAgICBjb25zdCB0eXBlID0gZ2V0QWN0aW9uVHlwZUZyb21JbnN0YW5jZShhY3Rpb24pITtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICBmb3IgKGNvbnN0IG1ldGFkYXRhIG9mIHRoaXMuc3RhdGVzKSB7XG4gICAgICBjb25zdCBhY3Rpb25NZXRhcyA9IG1ldGFkYXRhLmFjdGlvbnNbdHlwZV07XG5cbiAgICAgIGlmIChhY3Rpb25NZXRhcykge1xuICAgICAgICBmb3IgKGNvbnN0IGFjdGlvbk1ldGEgb2YgYWN0aW9uTWV0YXMpIHtcbiAgICAgICAgICBjb25zdCBzdGF0ZUNvbnRleHQgPSB0aGlzLl9zdGF0ZUNvbnRleHRGYWN0b3J5LmNyZWF0ZVN0YXRlQ29udGV4dChtZXRhZGF0YSk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBtZXRhZGF0YS5pbnN0YW5jZVthY3Rpb25NZXRhLmZuXShzdGF0ZUNvbnRleHQsIGFjdGlvbik7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IGZyb20ocmVzdWx0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzT2JzZXJ2YWJsZShyZXN1bHQpKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoaXMgb2JzZXJ2YWJsZSBoYXMgYmVlbiBjb21wbGV0ZWQgdy9vIGVtaXR0aW5nXG4gICAgICAgICAgICAgIC8vIGFueSB2YWx1ZSB0aGVuIHdlIHdvdWxkbid0IHdhbnQgdG8gY29tcGxldGUgdGhlIHdob2xlIGNoYWluXG4gICAgICAgICAgICAgIC8vIG9mIGFjdGlvbnMuIFNpbmNlIGlmIGFueSBvYnNlcnZhYmxlIGNvbXBsZXRlcyB0aGVuXG4gICAgICAgICAgICAgIC8vIGFjdGlvbiB3aWxsIGJlIGNhbmNlbGVkLlxuICAgICAgICAgICAgICAvLyBGb3IgaW5zdGFuY2UgaWYgYW55IGFjdGlvbiBoYW5kbGVyIHdvdWxkJ3ZlIGhhZCBzdWNoIHN0YXRlbWVudDpcbiAgICAgICAgICAgICAgLy8gYGhhbmRsZXIoY3R4KSB7IHJldHVybiBFTVBUWTsgfWBcbiAgICAgICAgICAgICAgLy8gdGhlbiB0aGUgYWN0aW9uIHdpbGwgYmUgY2FuY2VsZWQuXG4gICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbmd4cy9zdG9yZS9pc3N1ZXMvMTU2OFxuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucGlwZShcbiAgICAgICAgICAgICAgICBtZXJnZU1hcCgodmFsdWU6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJvbSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoaXNPYnNlcnZhYmxlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gb2YodmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRJZkVtcHR5KHt9KVxuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgIGlmIChhY3Rpb25NZXRhLm9wdGlvbnMuY2FuY2VsVW5jb21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyB0b2RvOiBvZkFjdGlvbkRpc3BhdGNoZWQgc2hvdWxkIGJlIHVzZWQgd2l0aCBhY3Rpb24gY2xhc3NcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucGlwZShcbiAgICAgICAgICAgICAgICAgIHRha2VVbnRpbChkaXNwYXRjaGVkJC5waXBlKG9mQWN0aW9uRGlzcGF0Y2hlZChhY3Rpb24gYXMgYW55KSkpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gb2Yoe30pLnBpcGUoc2hhcmVSZXBsYXkoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aHJvd0Vycm9yKGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICByZXN1bHRzLnB1c2gob2Yoe30pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm9ya0pvaW4ocmVzdWx0cyk7XG4gIH1cblxuICBwcml2YXRlIGFkZFRvU3RhdGVzTWFwKFxuICAgIHN0YXRlQ2xhc3NlczogU3RhdGVDbGFzc0ludGVybmFsW11cbiAgKTogeyBuZXdTdGF0ZXM6IFN0YXRlQ2xhc3NJbnRlcm5hbFtdIH0ge1xuICAgIGNvbnN0IG5ld1N0YXRlczogU3RhdGVDbGFzc0ludGVybmFsW10gPSBbXTtcbiAgICBjb25zdCBzdGF0ZXNNYXA6IFN0YXRlc0J5TmFtZSA9IHRoaXMuc3RhdGVzQnlOYW1lO1xuXG4gICAgZm9yIChjb25zdCBzdGF0ZUNsYXNzIG9mIHN0YXRlQ2xhc3Nlcykge1xuICAgICAgY29uc3Qgc3RhdGVOYW1lID0gZ2V0U3RvcmVNZXRhZGF0YShzdGF0ZUNsYXNzKS5uYW1lITtcbiAgICAgIC8vIENhcmV0YWtlciBub3RlOiB3ZSBoYXZlIHN0aWxsIGxlZnQgdGhlIGB0eXBlb2ZgIGNvbmRpdGlvbiBpbiBvcmRlciB0byBhdm9pZFxuICAgICAgLy8gY3JlYXRpbmcgYSBicmVha2luZyBjaGFuZ2UgZm9yIHByb2plY3RzIHRoYXQgc3RpbGwgdXNlIHRoZSBWaWV3IEVuZ2luZS5cbiAgICAgIGlmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpIHtcbiAgICAgICAgU3RvcmVWYWxpZGF0b3JzLmNoZWNrVGhhdFN0YXRlTmFtZUlzVW5pcXVlKHN0YXRlTmFtZSwgc3RhdGVDbGFzcywgc3RhdGVzTWFwKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHVubW91bnRlZFN0YXRlID0gIXN0YXRlc01hcFtzdGF0ZU5hbWVdO1xuICAgICAgaWYgKHVubW91bnRlZFN0YXRlKSB7XG4gICAgICAgIG5ld1N0YXRlcy5wdXNoKHN0YXRlQ2xhc3MpO1xuICAgICAgICBzdGF0ZXNNYXBbc3RhdGVOYW1lXSA9IHN0YXRlQ2xhc3M7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgbmV3U3RhdGVzIH07XG4gIH1cblxuICBwcml2YXRlIGFkZFJ1bnRpbWVJbmZvVG9NZXRhKG1ldGE6IE1ldGFEYXRhTW9kZWwsIHBhdGg6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuc3RhdGVQYXRoc1ttZXRhLm5hbWUhXSA9IHBhdGg7XG4gICAgLy8gVE9ETzogdjQgLSB3ZSBwbGFuIHRvIGdldCByaWQgb2YgdGhlIHBhdGggcHJvcGVydHkgYmVjYXVzZSBpdCBpcyBub24tZGV0ZXJtaW5pc3RpY1xuICAgIC8vIHdlIGNhbiBkbyB0aGlzIHdoZW4gd2UgZ2V0IHJpZCBvZiB0aGUgaW5jb3JyZWN0bHkgZXhwb3NlZCBnZXRTdG9yZU1ldGFkYXRhXG4gICAgLy8gV2Ugd2lsbCBuZWVkIHRvIGNvbWUgdXAgd2l0aCBhbiBhbHRlcm5hdGl2ZSBpbiB2NCBiZWNhdXNlIHRoaXMgaXMgdXNlZCBieSBtYW55IHBsdWdpbnNcbiAgICBtZXRhLnBhdGggPSBwYXRoO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiB0aGUgbWV0aG9kIGNoZWNrcyBpZiB0aGUgc3RhdGUgaGFzIGFscmVhZHkgYmVlbiBhZGRlZCB0byB0aGUgdHJlZVxuICAgKiBhbmQgY29tcGxldGVkIHRoZSBsaWZlIGN5Y2xlXG4gICAqIEBwYXJhbSBuYW1lXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqL1xuICBwcml2YXRlIGhhc0JlZW5Nb3VudGVkQW5kQm9vdHN0cmFwcGVkKG5hbWU6IHN0cmluZywgcGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgdmFsdWVJc0Jvb3RzdHJhcHBlZEluSW5pdGlhbFN0YXRlOiBib29sZWFuID1cbiAgICAgIGdldFZhbHVlKHRoaXMuX2luaXRpYWxTdGF0ZSwgcGF0aCkgIT09IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZXNCeU5hbWVbbmFtZV0gJiYgdmFsdWVJc0Jvb3RzdHJhcHBlZEluSW5pdGlhbFN0YXRlO1xuICB9XG59XG4iXX0=