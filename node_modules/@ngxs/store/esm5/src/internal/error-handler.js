/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ErrorHandler, Injectable, Injector } from '@angular/core';
import { Observable } from 'rxjs';
import { leaveNgxs } from '../operators/leave-ngxs';
import * as i0 from "@angular/core";
/**
 * This operator is used for piping the observable result
 * from the `dispatch()`. It has a "smart" error handling
 * strategy that allows us to decide whether we propagate
 * errors to Angular's `ErrorHandler` or enable users to
 * handle them manually. We consider following cases:
 * 1) `store.dispatch()` (no subscribe) -> call `handleError()`
 * 2) `store.dispatch().subscribe()` (no error callback) -> call `handleError()`
 * 3) `store.dispatch().subscribe({ error: ... })` -> don't call `handleError()`
 * 4) `toPromise()` without `catch` -> do `handleError()`
 * 5) `toPromise()` with `catch` -> don't `handleError()`
 * @template T
 * @param {?} internalErrorReporter
 * @param {?} ngxsExecutionStrategy
 * @return {?}
 */
export function ngxsErrorHandler(internalErrorReporter, ngxsExecutionStrategy) {
    return (/**
     * @param {?} source
     * @return {?}
     */
    function (source) {
        /** @type {?} */
        var subscribed = false;
        source.subscribe({
            error: (/**
             * @param {?} error
             * @return {?}
             */
            function (error) {
                // Do not trigger change detection for a microtask. This depends on the execution
                // strategy being used, but the default `DispatchOutsideZoneNgxsExecutionStrategy`
                // leaves the Angular zone.
                ngxsExecutionStrategy.enter((/**
                 * @return {?}
                 */
                function () {
                    return Promise.resolve().then((/**
                     * @return {?}
                     */
                    function () {
                        if (!subscribed) {
                            ngxsExecutionStrategy.leave((/**
                             * @return {?}
                             */
                            function () {
                                return internalErrorReporter.reportErrorSafely(error);
                            }));
                        }
                    }));
                }));
            })
        });
        return new Observable((/**
         * @param {?} subscriber
         * @return {?}
         */
        function (subscriber) {
            subscribed = true;
            return source.pipe(leaveNgxs(ngxsExecutionStrategy)).subscribe(subscriber);
        }));
    });
}
var InternalErrorReporter = /** @class */ (function () {
    function InternalErrorReporter(_injector) {
        this._injector = _injector;
        /**
         * Will be set lazily to be backward compatible.
         */
        this._errorHandler = (/** @type {?} */ (null));
    }
    /**
     * @param {?} error
     * @return {?}
     */
    InternalErrorReporter.prototype.reportErrorSafely = /**
     * @param {?} error
     * @return {?}
     */
    function (error) {
        if (this._errorHandler === null) {
            this._errorHandler = this._injector.get(ErrorHandler);
        }
        // The `try-catch` is used to avoid handling the error twice. Suppose we call
        // `handleError` which re-throws the error internally. The re-thrown error will
        // be caught by zone.js which will then get to the `zone.onError.emit()` and the
        // `onError` subscriber will call `handleError` again.
        try {
            this._errorHandler.handleError(error);
        }
        catch (_a) { }
    };
    InternalErrorReporter.decorators = [
        { type: Injectable, args: [{ providedIn: 'root' },] }
    ];
    /** @nocollapse */
    InternalErrorReporter.ctorParameters = function () { return [
        { type: Injector }
    ]; };
    /** @nocollapse */ InternalErrorReporter.ngInjectableDef = i0.defineInjectable({ factory: function InternalErrorReporter_Factory() { return new InternalErrorReporter(i0.inject(i0.INJECTOR)); }, token: InternalErrorReporter, providedIn: "root" });
    return InternalErrorReporter;
}());
export { InternalErrorReporter };
if (false) {
    /**
     * Will be set lazily to be backward compatible.
     * @type {?}
     * @private
     */
    InternalErrorReporter.prototype._errorHandler;
    /**
     * @type {?}
     * @private
     */
    InternalErrorReporter.prototype._injector;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXJyb3ItaGFuZGxlci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuZ3hzL3N0b3JlLyIsInNvdXJjZXMiOlsic3JjL2ludGVybmFsL2Vycm9yLWhhbmRsZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxZQUFZLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNuRSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBRWxDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZXBELE1BQU0sVUFBVSxnQkFBZ0IsQ0FDOUIscUJBQTRDLEVBQzVDLHFCQUE0QztJQUU1Qzs7OztJQUFPLFVBQUMsTUFBcUI7O1lBQ3ZCLFVBQVUsR0FBRyxLQUFLO1FBRXRCLE1BQU0sQ0FBQyxTQUFTLENBQUM7WUFDZixLQUFLOzs7O1lBQUUsVUFBQSxLQUFLO2dCQUNWLGlGQUFpRjtnQkFDakYsa0ZBQWtGO2dCQUNsRiwyQkFBMkI7Z0JBQzNCLHFCQUFxQixDQUFDLEtBQUs7OztnQkFBQztvQkFDMUIsT0FBQSxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUMsSUFBSTs7O29CQUFDO3dCQUNyQixJQUFJLENBQUMsVUFBVSxFQUFFOzRCQUNmLHFCQUFxQixDQUFDLEtBQUs7Ozs0QkFBQztnQ0FDMUIsT0FBQSxxQkFBcUIsQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUM7NEJBQTlDLENBQThDLEVBQy9DLENBQUM7eUJBQ0g7b0JBQ0gsQ0FBQyxFQUFDO2dCQU5GLENBTUUsRUFDSCxDQUFDO1lBQ0osQ0FBQyxDQUFBO1NBQ0YsQ0FBQyxDQUFDO1FBRUgsT0FBTyxJQUFJLFVBQVU7Ozs7UUFBQyxVQUFBLFVBQVU7WUFDOUIsVUFBVSxHQUFHLElBQUksQ0FBQztZQUNsQixPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDN0UsQ0FBQyxFQUFDLENBQUM7SUFDTCxDQUFDLEVBQUM7QUFDSixDQUFDO0FBRUQ7SUFLRSwrQkFBb0IsU0FBbUI7UUFBbkIsY0FBUyxHQUFULFNBQVMsQ0FBVTs7OztRQUYvQixrQkFBYSxHQUFpQixtQkFBQSxJQUFJLEVBQUMsQ0FBQztJQUVGLENBQUM7Ozs7O0lBRTNDLGlEQUFpQjs7OztJQUFqQixVQUFrQixLQUFVO1FBQzFCLElBQUksSUFBSSxDQUFDLGFBQWEsS0FBSyxJQUFJLEVBQUU7WUFDL0IsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQztTQUN2RDtRQUNELDZFQUE2RTtRQUM3RSwrRUFBK0U7UUFDL0UsZ0ZBQWdGO1FBQ2hGLHNEQUFzRDtRQUN0RCxJQUFJO1lBQ0YsSUFBSSxDQUFDLGFBQWEsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDdkM7UUFBQyxXQUFNLEdBQUU7SUFDWixDQUFDOztnQkFsQkYsVUFBVSxTQUFDLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRTs7OztnQkFqREMsUUFBUTs7O2dDQUEzQztDQW9FQyxBQW5CRCxJQW1CQztTQWxCWSxxQkFBcUI7Ozs7Ozs7SUFFaEMsOENBQTRDOzs7OztJQUVoQywwQ0FBMkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFcnJvckhhbmRsZXIsIEluamVjdGFibGUsIEluamVjdG9yIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IGxlYXZlTmd4cyB9IGZyb20gJy4uL29wZXJhdG9ycy9sZWF2ZS1uZ3hzJztcbmltcG9ydCB7IE5neHNFeGVjdXRpb25TdHJhdGVneSB9IGZyb20gJy4uL2V4ZWN1dGlvbi9zeW1ib2xzJztcblxuLyoqXG4gKiBUaGlzIG9wZXJhdG9yIGlzIHVzZWQgZm9yIHBpcGluZyB0aGUgb2JzZXJ2YWJsZSByZXN1bHRcbiAqIGZyb20gdGhlIGBkaXNwYXRjaCgpYC4gSXQgaGFzIGEgXCJzbWFydFwiIGVycm9yIGhhbmRsaW5nXG4gKiBzdHJhdGVneSB0aGF0IGFsbG93cyB1cyB0byBkZWNpZGUgd2hldGhlciB3ZSBwcm9wYWdhdGVcbiAqIGVycm9ycyB0byBBbmd1bGFyJ3MgYEVycm9ySGFuZGxlcmAgb3IgZW5hYmxlIHVzZXJzIHRvXG4gKiBoYW5kbGUgdGhlbSBtYW51YWxseS4gV2UgY29uc2lkZXIgZm9sbG93aW5nIGNhc2VzOlxuICogMSkgYHN0b3JlLmRpc3BhdGNoKClgIChubyBzdWJzY3JpYmUpIC0+IGNhbGwgYGhhbmRsZUVycm9yKClgXG4gKiAyKSBgc3RvcmUuZGlzcGF0Y2goKS5zdWJzY3JpYmUoKWAgKG5vIGVycm9yIGNhbGxiYWNrKSAtPiBjYWxsIGBoYW5kbGVFcnJvcigpYFxuICogMykgYHN0b3JlLmRpc3BhdGNoKCkuc3Vic2NyaWJlKHsgZXJyb3I6IC4uLiB9KWAgLT4gZG9uJ3QgY2FsbCBgaGFuZGxlRXJyb3IoKWBcbiAqIDQpIGB0b1Byb21pc2UoKWAgd2l0aG91dCBgY2F0Y2hgIC0+IGRvIGBoYW5kbGVFcnJvcigpYFxuICogNSkgYHRvUHJvbWlzZSgpYCB3aXRoIGBjYXRjaGAgLT4gZG9uJ3QgYGhhbmRsZUVycm9yKClgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBuZ3hzRXJyb3JIYW5kbGVyPFQ+KFxuICBpbnRlcm5hbEVycm9yUmVwb3J0ZXI6IEludGVybmFsRXJyb3JSZXBvcnRlcixcbiAgbmd4c0V4ZWN1dGlvblN0cmF0ZWd5OiBOZ3hzRXhlY3V0aW9uU3RyYXRlZ3lcbikge1xuICByZXR1cm4gKHNvdXJjZTogT2JzZXJ2YWJsZTxUPikgPT4ge1xuICAgIGxldCBzdWJzY3JpYmVkID0gZmFsc2U7XG5cbiAgICBzb3VyY2Uuc3Vic2NyaWJlKHtcbiAgICAgIGVycm9yOiBlcnJvciA9PiB7XG4gICAgICAgIC8vIERvIG5vdCB0cmlnZ2VyIGNoYW5nZSBkZXRlY3Rpb24gZm9yIGEgbWljcm90YXNrLiBUaGlzIGRlcGVuZHMgb24gdGhlIGV4ZWN1dGlvblxuICAgICAgICAvLyBzdHJhdGVneSBiZWluZyB1c2VkLCBidXQgdGhlIGRlZmF1bHQgYERpc3BhdGNoT3V0c2lkZVpvbmVOZ3hzRXhlY3V0aW9uU3RyYXRlZ3lgXG4gICAgICAgIC8vIGxlYXZlcyB0aGUgQW5ndWxhciB6b25lLlxuICAgICAgICBuZ3hzRXhlY3V0aW9uU3RyYXRlZ3kuZW50ZXIoKCkgPT5cbiAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmICghc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgICBuZ3hzRXhlY3V0aW9uU3RyYXRlZ3kubGVhdmUoKCkgPT5cbiAgICAgICAgICAgICAgICBpbnRlcm5hbEVycm9yUmVwb3J0ZXIucmVwb3J0RXJyb3JTYWZlbHkoZXJyb3IpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShzdWJzY3JpYmVyID0+IHtcbiAgICAgIHN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHNvdXJjZS5waXBlKGxlYXZlTmd4cyhuZ3hzRXhlY3V0aW9uU3RyYXRlZ3kpKS5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgfSk7XG4gIH07XG59XG5cbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXG5leHBvcnQgY2xhc3MgSW50ZXJuYWxFcnJvclJlcG9ydGVyIHtcbiAgLyoqIFdpbGwgYmUgc2V0IGxhemlseSB0byBiZSBiYWNrd2FyZCBjb21wYXRpYmxlLiAqL1xuICBwcml2YXRlIF9lcnJvckhhbmRsZXI6IEVycm9ySGFuZGxlciA9IG51bGwhO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2luamVjdG9yOiBJbmplY3Rvcikge31cblxuICByZXBvcnRFcnJvclNhZmVseShlcnJvcjogYW55KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX2Vycm9ySGFuZGxlciA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fZXJyb3JIYW5kbGVyID0gdGhpcy5faW5qZWN0b3IuZ2V0KEVycm9ySGFuZGxlcik7XG4gICAgfVxuICAgIC8vIFRoZSBgdHJ5LWNhdGNoYCBpcyB1c2VkIHRvIGF2b2lkIGhhbmRsaW5nIHRoZSBlcnJvciB0d2ljZS4gU3VwcG9zZSB3ZSBjYWxsXG4gICAgLy8gYGhhbmRsZUVycm9yYCB3aGljaCByZS10aHJvd3MgdGhlIGVycm9yIGludGVybmFsbHkuIFRoZSByZS10aHJvd24gZXJyb3Igd2lsbFxuICAgIC8vIGJlIGNhdWdodCBieSB6b25lLmpzIHdoaWNoIHdpbGwgdGhlbiBnZXQgdG8gdGhlIGB6b25lLm9uRXJyb3IuZW1pdCgpYCBhbmQgdGhlXG4gICAgLy8gYG9uRXJyb3JgIHN1YnNjcmliZXIgd2lsbCBjYWxsIGBoYW5kbGVFcnJvcmAgYWdhaW4uXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2Vycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgfSBjYXRjaCB7fVxuICB9XG59XG4iXX0=